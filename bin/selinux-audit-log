#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# SPDX-License-Identifier: MIT
# Copyright (c) 2019-2024 Nicolas Iooss
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
"""Parse SELinux audit log and print events"""
import argparse
import binascii
import collections
from contextlib import suppress
import datetime
import logging
import os
import re
import signal
import shlex
import subprocess
import sys
from typing import Dict, FrozenSet, List, Mapping, Optional, Sequence, Tuple, TYPE_CHECKING, Union


# Use local timezone, if possible
try:
    from dateutil.tz import tzlocal
except ImportError:
    if not TYPE_CHECKING:
        def tzlocal():
            """Simulate an empty timezone"""
            return None


logger = logging.getLogger(__name__)


DEFAULT_AUDIT_LOG_PATH = '/var/log/audit/audit.log'

COLOR_RED: str = '\033[31m'
COLOR_BOLDRED: str = '\033[31;1m'
COLOR_GREEN: str = '\033[32m'
COLOR_YELLOW: str = '\033[33m'
COLOR_PURPLE: str = '\033[35m'
COLOR_CYAN: str = '\033[36m'
COLOR_NORM: str = '\033[m'


# Enum from /usr/include/linux/audit.h
# (https://github.com/torvalds/linux/blob/master/include/uapi/linux/audit.h)
# and from /usr/include/libaudit.h
# (https://github.com/linux-audit/audit-userspace/blob/v2.8.5/lib/libaudit.h)
AUDIT_TYPES: Mapping[int, str] = {
    # 1000 - 1099 are for commanding the audit system
    1000: 'GET',
    1001: 'SET',
    1002: 'LIST',
    1003: 'ADD',
    1004: 'DEL',
    1005: 'USER',
    1006: 'LOGIN',
    1007: 'WATCH_INS',
    1008: 'WATCH_REM',
    1009: 'WATCH_LIST',
    1010: 'SIGNAL_INFO',
    1011: 'ADD_RULE',
    1012: 'DEL_RULE',
    1013: 'LIST_RULES',
    1014: 'TRIM',
    1015: 'MAKE_EQUIV',
    1016: 'TTY_GET',
    1017: 'TTY_SET',
    1018: 'SET_FEATURE',
    1019: 'GET_FEATURE',

    # 1100 - 1199 user space trusted application messages
    1100: 'USER_AUTH',
    1101: 'USER_ACCT',
    1102: 'USER_MGMT',
    1103: 'CRED_ACQ',
    1104: 'CRED_DISP',
    1105: 'USER_START',
    1106: 'USER_END',
    1107: 'USER_AVC',
    1108: 'USER_CHAUTHTOK',
    1109: 'USER_ERR',
    1110: 'CRED_REFR',
    1111: 'USYS_CONFIG',
    1112: 'USER_LOGIN',
    1113: 'USER_LOGOUT',
    1114: 'ADD_USER',
    1115: 'DEL_USER',
    1116: 'ADD_GROUP',
    1117: 'DEL_GROUP',
    1118: 'DAC_CHECK',
    1119: 'CHGRP_ID',
    1120: 'TEST',
    1121: 'TRUSTED_APP',
    1122: 'USER_SELINUX_ERR',
    1123: 'USER_CMD',
    1124: 'USER_TTY',
    1125: 'CHUSER_ID',
    1126: 'GRP_AUTH',
    1127: 'SYSTEM_BOOT',
    1128: 'SYSTEM_SHUTDOWN',
    1129: 'SYSTEM_RUNLEVEL',
    1130: 'SERVICE_START',
    1131: 'SERVICE_STOP',
    1132: 'GRP_MGMT',
    1133: 'GRP_CHAUTHTOK',
    1134: 'MAC_CHECK',
    1135: 'ACCT_LOCK',
    1136: 'ACCT_UNLOCK',
    1137: 'USER_DEVICE',
    1138: 'SOFTWARE_UPDATE',

    # 1200 - 1299 messages internal to the audit daemon
    1200: 'DAEMON_START',
    1201: 'DAEMON_END',
    1202: 'DAEMON_ABORT',
    1203: 'DAEMON_CONFIG',
    1204: 'DAEMON_RECONFIG',
    1205: 'DAEMON_ROTATE',
    1206: 'DAEMON_RESUME',
    1207: 'DAEMON_ACCEPT',
    1208: 'DAEMON_CLOSE',
    1209: 'DAEMON_ERR',

    # 1300 - 1399 audit event messages
    1300: 'SYSCALL',
    1301: 'FS_WATCH',
    1302: 'PATH',
    1303: 'IPC',
    1304: 'SOCKETCALL',
    1305: 'CONFIG_CHANGE',
    1306: 'SOCKADDR',
    1307: 'CWD',
    1309: 'EXECVE',
    1311: 'IPC_SET_PERM',
    1312: 'MQ_OPEN',
    1313: 'MQ_SENDRECV',
    1314: 'MQ_NOTIFY',
    1315: 'MQ_GETSETATTR',
    1316: 'KERNEL_OTHER',
    1317: 'FD_PAIR',
    1318: 'OBJ_PID',
    1319: 'TTY',
    1320: 'EOE',
    1321: 'BPRM_FCAPS',
    1322: 'CAPSET',
    1323: 'MMAP',
    1324: 'NETFILTER_PKT',
    1325: 'NETFILTER_CFG',
    1326: 'SECCOMP',
    1327: 'PROCTITLE',
    1328: 'FEATURE_CHANGE',
    1329: 'REPLACE',
    1330: 'KERN_MODULE',
    1331: 'FANOTIFY',
    1332: 'TIME_INJOFFSET',
    1333: 'TIME_ADJNTPVAL',
    1334: 'BPF',
    1335: 'AUDIT_EVENT_LISTENER',
    1336: 'URINGOP',
    1337: 'OPENAT2',
    1338: 'DM_CTRL',
    1339: 'DM_EVENT',

    # 1400 - 1499 SELinux use
    1400: 'AVC',
    1401: 'SELINUX_ERR',
    1402: 'AVC_PATH',
    1403: 'MAC_POLICY_LOAD',
    1404: 'MAC_STATUS',
    1405: 'MAC_CONFIG_CHANGE',
    1406: 'MAC_UNLBL_ALLOW',
    1407: 'MAC_CIPSOV4_ADD',
    1408: 'MAC_CIPSOV4_DEL',
    1409: 'MAC_MAP_ADD',
    1410: 'MAC_MAP_DEL',
    1411: 'MAC_IPSEC_ADDSA',
    1412: 'MAC_IPSEC_DELSA',
    1413: 'MAC_IPSEC_ADDSPD',
    1414: 'MAC_IPSEC_DELSPD',
    1415: 'MAC_IPSEC_EVENT',
    1416: 'MAC_UNLBL_STCADD',
    1417: 'MAC_UNLBL_STCDEL',
    1418: 'MAC_CALIPSO_ADD',
    1419: 'MAC_CALIPSO_DEL',
    1420: 'MAC_TASK_CONTEXTS',

    # 1500 - 1599 kernel LSPP events
    1500: 'AA',
    1501: 'APPARMOR_AUDIT',
    1502: 'APPARMOR_ALLOWED',
    1503: 'APPARMOR_DENIED',
    1504: 'APPARMOR_HINT',
    1505: 'APPARMOR_STATUS',
    1506: 'APPARMOR_ERROR',

    # 1700 - 1799 kernel anomaly records
    1700: 'ANOM_PROMISCUOUS',
    1701: 'ANOM_ABEND',
    1702: 'ANOM_LINK',
    1703: 'ANOM_CREAT',

    # 1800 - 1899 kernel integrity events
    1800: 'INTEGRITY_DATA',
    1801: 'INTEGRITY_METADATA',
    1802: 'INTEGRITY_STATUS',
    1803: 'INTEGRITY_HASH',
    1804: 'INTEGRITY_PCR',
    1805: 'INTEGRITY_RULE',
    1806: 'INTEGRITY_EVM_XATTR',
    1807: 'INTEGRITY_POLICY_RULE',

    # 2000 is for otherwise unclassified kernel audit messages (legacy)
    2000: 'KERNEL',  # On Android 11: "state=initialized audit_enabled=0 res=1"

    # 2001 - 2099 unused (kernel)

    # 2100 - 2199 user space anomaly records
    2100: 'ANOM_LOGIN_FAILURES',
    2101: 'ANOM_LOGIN_TIME',
    2102: 'ANOM_LOGIN_SESSIONS',
    2103: 'ANOM_LOGIN_ACCT',
    2104: 'ANOM_LOGIN_LOCATION',
    2105: 'ANOM_MAX_DAC',
    2106: 'ANOM_MAX_MAC',
    2107: 'ANOM_AMTU_FAIL',
    2108: 'ANOM_RBAC_FAIL',
    2109: 'ANOM_RBAC_INTEGRITY_FAIL',
    2110: 'ANOM_CRYPTO_FAIL',
    2111: 'ANOM_ACCESS_FS',
    2112: 'ANOM_EXEC',
    2113: 'ANOM_MK_EXEC',
    2114: 'ANOM_ADD_ACCT',
    2115: 'ANOM_DEL_ACCT',
    2116: 'ANOM_MOD_ACCT',
    2117: 'ANOM_ROOT_TRANS',
    2118: 'ANOM_LOGIN_SERVICE',

    # 2200 - 2299 user space actions taken in response to anomalies
    2200: 'RESP_ANOMALY',
    2201: 'RESP_ALERT',
    2202: 'RESP_KILL_PROC',
    2203: 'RESP_TERM_ACCESS',
    2204: 'RESP_ACCT_REMOTE',
    2205: 'RESP_ACCT_LOCK_TIMED',
    2206: 'RESP_ACCT_UNLOCK_TIMED',
    2207: 'RESP_ACCT_LOCK',
    2208: 'RESP_TERM_LOCK',
    2209: 'RESP_SEBOOL',
    2210: 'RESP_EXEC',
    2211: 'RESP_SINGLE',
    2212: 'RESP_HALT',
    2213: 'RESP_ORIGIN_BLOCK',
    2214: 'RESP_ORIGIN_BLOCK_TIMED',

    # 2300 - 2399 user space generated LSPP events
    2300: 'USER_ROLE_CHANGE',
    2301: 'ROLE_ASSIGN',
    2302: 'ROLE_REMOVE',
    2303: 'LABEL_OVERRIDE',
    2304: 'LABEL_LEVEL_CHANGE',
    2305: 'USER_LABELED_EXPORT',
    2306: 'USER_UNLABELED_EXPORT',
    2307: 'DEV_ALLOC',
    2308: 'DEV_DEALLOC',
    2309: 'FS_RELABEL',
    2310: 'USER_MAC_POLICY_LOAD',
    2311: 'ROLE_MODIFY',
    2312: 'USER_MAC_CONFIG_CHANGE',

    # 2400 - 2499 user space crypto events
    2400: 'CRYPTO_TEST_USER',
    2401: 'CRYPTO_PARAM_CHANGE_USER',
    2402: 'CRYPTO_LOGIN',
    2403: 'CRYPTO_LOGOUT',
    2404: 'CRYPTO_KEY_USER',
    2405: 'CRYPTO_FAILURE_USER',
    2406: 'CRYPTO_REPLAY_USER',
    2407: 'CRYPTO_SESSION',
    2408: 'CRYPTO_IKE_SA',
    2409: 'CRYPTO_IPSEC_SA',

    2500: 'VIRT_CONTROL',
    2501: 'VIRT_RESOURCE',
    2502: 'VIRT_MACHINE_ID',
    2503: 'VIRT_INTEGRITY_CHECK',
    2504: 'VIRT_CREATE',
    2505: 'VIRT_DESTROY',
    2506: 'VIRT_MIGRATE_IN',
    2507: 'VIRT_MIGRATE_OUT',
}
AUDIT_TYPES_FOR_SELINUX: FrozenSet[str] = frozenset((
    'AVC',
    'SELINUX_ERR',
    'USER_AVC',
    'USER_SELINUX_ERR',
))

AUDIT_DECIMAL_INTEGER_FIELDS: FrozenSet[Tuple[str, str]] = frozenset((
    ('EXECVE', 'argc'),
    ('CONFIG_CHANGE', 'audit_backlog_limit'),
    ('CONFIG_CHANGE', 'audit_backlog_wait_time'),
    ('CONFIG_CHANGE', 'audit_enabled'),
    ('KERNEL', 'audit_enabled'),
    ('CONFIG_CHANGE', 'audit_failure'),
    ('CONFIG_CHANGE', 'audit_pid'),
    ('ADD_GROUP', 'auid'),
    ('ADD_USER', 'auid'),
    ('ANOM_ABEND', 'auid'),
    ('ANOM_PROMISCUOUS', 'auid'),
    ('AUDIT_EVENT_LISTENER', 'auid'),
    ('CONFIG_CHANGE', 'auid'),
    ('CRED_ACQ', 'auid'),
    ('CRED_DISP', 'auid'),
    ('CRED_REFR', 'auid'),
    ('CRYPTO_KEY_USER', 'auid'),
    ('CRYPTO_SESSION', 'auid'),
    ('DAEMON_END', 'auid'),
    ('DAEMON_START', 'auid'),
    ('FS_RELABEL', 'auid'),
    ('LOGIN', 'auid'),
    ('MAC_CALIPSO_ADD', 'auid'),
    ('MAC_CALIPSO_DEL', 'auid'),
    ('MAC_CIPSOV4_ADD', 'auid'),
    ('MAC_CIPSOV4_DEL', 'auid'),
    ('MAC_CONFIG_CHANGE', 'auid'),
    ('MAC_IPSEC_EVENT', 'auid'),
    ('MAC_MAP_ADD', 'auid'),
    ('MAC_MAP_DEL', 'auid'),
    ('MAC_POLICY_LOAD', 'auid'),
    ('MAC_STATUS', 'auid'),
    ('MAC_UNLBL_ALLOW', 'auid'),
    ('MAC_UNLBL_STCADD', 'auid'),
    ('MAC_UNLBL_STCDEL', 'auid'),
    ('ROLE_ASSIGN', 'auid'),
    ('SECCOMP', 'auid'),
    ('SERVICE_START', 'auid'),
    ('SERVICE_STOP', 'auid'),
    ('SYSCALL', 'auid'),
    ('SYSTEM_BOOT', 'auid'),
    ('SYSTEM_RUNLEVEL', 'auid'),
    ('SYSTEM_SHUTDOWN', 'auid'),
    ('USER_ACCT', 'auid'),
    ('USER_AUTH', 'auid'),
    ('USER_AVC', 'auid'),
    ('USER_CHAUTHTOK', 'auid'),
    ('USER_CMD', 'auid'),
    ('USER_END', 'auid'),
    ('USER_ERR', 'auid'),
    ('USER_LOGIN', 'auid'),
    ('USER_LOGOUT', 'auid'),
    ('USER_MAC_CONFIG_CHANGE', 'auid'),
    ('USER_ROLE_CHANGE', 'auid'),
    ('USER_SELINUX_ERR', 'auid'),
    ('USER_START', 'auid'),
    ('USYS_CONFIG', 'auid'),
    ('VIRT_CONTROL', 'auid'),
    ('VIRT_MACHINE_ID', 'auid'),
    ('VIRT_RESOURCE', 'auid'),
    ('MAC_MAP_ADD', 'calipso_doi'),
    ('MAC_CALIPSO_ADD', 'calipso_doi'),
    ('MAC_CALIPSO_DEL', 'calipso_doi'),
    ('MAC_CIPSOV4_ADD', 'calipso_doi'),
    ('MAC_CIPSOV4_DEL', 'calipso_doi'),
    ('PATH', 'cap_fe'),
    ('PATH', 'cap_fi'),
    ('PATH', 'cap_fp'),
    ('PATH', 'cap_frootid'),
    ('PATH', 'cap_fver'),
    ('CAPSET', 'cap_pa'),
    ('CAPSET', 'cap_pe'),
    ('CAPSET', 'cap_pi'),
    ('CAPSET', 'cap_pp'),
    ('AVC', 'capability'),
    ('MAC_CIPSOV4_ADD', 'cipso_doi'),
    ('MAC_CIPSOV4_DEL', 'cipso_doi'),
    ('MAC_MAP_ADD', 'cipso_doi'),
    ('SECCOMP', 'compat'),
    ('AVC', 'dest'),
    ('MAC_MAP_ADD', 'dst_prefixlen'),
    ('SYSCALL', 'egid'),
    ('MAC_STATUS', 'enabled'),
    ('MAC_STATUS', 'enforcing'),
    ('NETFILTER_CFG', 'entries'),
    ('AVC', 'error'),
    ('SYSCALL', 'euid'),
    ('SYSCALL', 'exit'),
    ('NETFILTER_CFG', 'family'),
    ('AVC', 'fport'),
    ('BPRM_FCAPS', 'frootid'),
    ('SYSCALL', 'fsgid'),
    ('AVC', 'fsuid'),
    ('SYSCALL', 'fsuid'),
    ('BPRM_FCAPS', 'fver'),
    ('ANOM_ABEND', 'gid'),
    ('ANOM_PROMISCUOUS', 'gid'),
    ('SECCOMP', 'gid'),
    ('SYSCALL', 'gid'),
    ('USER_AVC', 'gid'),
    ('ADD_GROUP', 'id'),
    ('ADD_USER', 'id'),
    ('USER_CHAUTHTOK', 'id'),
    ('USER_END', 'id'),
    ('USER_LOGIN', 'id'),
    ('USER_LOGOUT', 'id'),
    ('USER_START', 'id'),
    ('USYS_CONFIG', 'ifindex'),
    ('AVC', 'ino'),
    ('PATH', 'inode'),
    ('PATH', 'item'),
    ('SYSCALL', 'items'),
    ('AVC', 'key'),
    ('CRYPTO_SESSION', 'ksize'),
    ('CONFIG_CHANGE', 'list'),
    ('AVC', 'lport'),
    ('CRYPTO_KEY_USER', 'lport'),
    ('CRYPTO_SESSION', 'lport'),
    ('VIRT_RESOURCE', 'maj'),
    ('TIME_ADJNTPVAL', 'new'),
    ('SYSTEM_RUNLEVEL', 'new-level'),
    ('VIRT_RESOURCE', 'new-mem'),
    ('VIRT_RESOURCE', 'new-vcpu'),
    ('AUDIT_EVENT_LISTENER', 'nl-mcgrp'),
    ('SOCKADDR', 'nlnk-fam'),
    ('SOCKADDR', 'nlnk-pid'),
    ('TIME_INJOFFSET', 'nsec'),
    ('PATH', 'ogid'),
    ('CONFIG_CHANGE', 'old'),
    ('MAC_UNLBL_ALLOW', 'old'),
    ('TIME_ADJNTPVAL', 'old'),
    ('LOGIN', 'old-auid'),
    ('MAC_STATUS', 'old-enabled'),
    ('VIRT_RESOURCE', 'old-mem'),
    ('LOGIN', 'old-ses'),
    ('VIRT_RESOURCE', 'old-vcpu'),
    ('MAC_STATUS', 'old_enforcing'),
    ('ANOM_PROMISCUOUS', 'old_prom'),
    ('MAC_CONFIG_CHANGE', 'old_val'),
    ('AVC', 'ouid'),
    ('PATH', 'ouid'),
    ('USER_AVC', 'peer_pid'),
    ('AVC', 'permissive'),
    ('USER_AVC', 'permissive'),
    ('ADD_GROUP', 'pid'),
    ('ADD_USER', 'pid'),
    ('ANOM_ABEND', 'pid'),
    ('AUDIT_EVENT_LISTENER', 'pid'),
    ('AVC', 'pid'),
    ('CAPSET', 'pid'),
    ('CRED_ACQ', 'pid'),
    ('CRED_DISP', 'pid'),
    ('CRED_REFR', 'pid'),
    ('CRYPTO_KEY_USER', 'pid'),
    ('CRYPTO_SESSION', 'pid'),
    ('DAEMON_END', 'pid'),
    ('DAEMON_START', 'pid'),
    ('FS_RELABEL', 'pid'),
    ('LOGIN', 'pid'),
    ('NETFILTER_CFG', 'pid'),
    ('ROLE_ASSIGN', 'pid'),
    ('SECCOMP', 'pid'),
    ('USER_ACCT', 'pid'),
    ('USER_AUTH', 'pid'),
    ('USER_AVC', 'pid'),
    ('USER_CHAUTHTOK', 'pid'),
    ('USER_CMD', 'pid'),
    ('USER_END', 'pid'),
    ('USER_ERR', 'pid'),
    ('USER_LOGIN', 'pid'),
    ('USER_LOGOUT', 'pid'),
    ('USER_MAC_CONFIG_CHANGE', 'pid'),
    ('USER_ROLE_CHANGE', 'pid'),
    ('USER_SELINUX_ERR', 'pid'),
    ('USER_START', 'pid'),
    ('SERVICE_START', 'pid'),
    ('SERVICE_STOP', 'pid'),
    ('SYSCALL', 'pid'),
    ('SYSTEM_BOOT', 'pid'),
    ('SYSTEM_RUNLEVEL', 'pid'),
    ('SYSTEM_SHUTDOWN', 'pid'),
    ('USYS_CONFIG', 'pid'),
    ('VIRT_CONTROL', 'pid'),
    ('VIRT_MACHINE_ID', 'pid'),
    ('VIRT_RESOURCE', 'pid'),
    ('SYSCALL', 'ppid'),
    ('BPF', 'prog-id'),
    ('ANOM_PROMISCUOUS', 'prom'),
    ('AVC', 'protocol'),
    ('ANOM_ABEND', 'res'),
    ('AUDIT_EVENT_LISTENER', 'res'),
    ('CONFIG_CHANGE', 'res'),
    ('KERNEL', 'res'),
    ('LOGIN', 'res'),
    ('MAC_CALIPSO_ADD', 'res'),
    ('MAC_CALIPSO_DEL', 'res'),
    ('MAC_CIPSOV4_ADD', 'res'),
    ('MAC_CIPSOV4_DEL', 'res'),
    ('MAC_IPSEC_EVENT', 'res'),
    ('MAC_MAP_ADD', 'res'),
    ('MAC_MAP_DEL', 'res'),
    ('MAC_POLICY_LOAD', 'res'),
    ('MAC_STATUS', 'res'),
    ('MAC_UNLBL_STCADD', 'res'),
    ('MAC_UNLBL_STCDEL', 'res'),
    ('USER_AVC', 'res'),
    ('USER_ACCT', 'reset'),
    ('CRYPTO_KEY_USER', 'rport'),
    ('CRYPTO_SESSION', 'rport'),
    ('USER_AVC', 'sauid'),
    ('USER_SELINUX_ERR', 'sauid'),
    ('TIME_INJOFFSET', 'sec'),
    ('MAC_IPSEC_EVENT', 'sec_alg'),
    ('MAC_IPSEC_EVENT', 'sec_doi'),
    ('USER_AVC', 'seqno'),
    ('ADD_GROUP', 'ses'),
    ('ADD_USER', 'ses'),
    ('ANOM_ABEND', 'ses'),
    ('ANOM_PROMISCUOUS', 'ses'),
    ('AUDIT_EVENT_LISTENER', 'ses'),
    ('CONFIG_CHANGE', 'ses'),
    ('CRED_ACQ', 'ses'),
    ('CRED_DISP', 'ses'),
    ('CRED_REFR', 'ses'),
    ('CONFIG_CHANGE', 'ses'),
    ('CRYPTO_KEY_USER', 'ses'),
    ('CRYPTO_SESSION', 'ses'),
    ('DAEMON_END', 'ses'),
    ('DAEMON_START', 'ses'),
    ('FS_RELABEL', 'ses'),
    ('LOGIN', 'ses'),
    ('MAC_CALIPSO_ADD', 'ses'),
    ('MAC_CALIPSO_DEL', 'ses'),
    ('MAC_CIPSOV4_ADD', 'ses'),
    ('MAC_CIPSOV4_DEL', 'ses'),
    ('MAC_CONFIG_CHANGE', 'ses'),
    ('MAC_IPSEC_EVENT', 'ses'),
    ('MAC_MAP_DEL', 'ses'),
    ('MAC_MAP_ADD', 'ses'),
    ('MAC_POLICY_LOAD', 'ses'),
    ('MAC_UNLBL_ALLOW', 'ses'),
    ('MAC_UNLBL_STCADD', 'ses'),
    ('MAC_UNLBL_STCDEL', 'ses'),
    ('MAC_STATUS', 'ses'),
    ('ROLE_ASSIGN', 'ses'),
    ('SECCOMP', 'ses'),
    ('SERVICE_START', 'ses'),
    ('SERVICE_STOP', 'ses'),
    ('SYSCALL', 'ses'),
    ('SYSTEM_BOOT', 'ses'),
    ('SYSTEM_RUNLEVEL', 'ses'),
    ('SYSTEM_SHUTDOWN', 'ses'),
    ('USER_ACCT', 'ses'),
    ('USER_AUTH', 'ses'),
    ('USER_AVC', 'ses'),
    ('USER_CHAUTHTOK', 'ses'),
    ('USER_CMD', 'ses'),
    ('USER_END', 'ses'),
    ('USER_ERR', 'ses'),
    ('USER_LOGIN', 'ses'),
    ('USER_LOGOUT', 'ses'),
    ('USER_MAC_CONFIG_CHANGE', 'ses'),
    ('USER_ROLE_CHANGE', 'ses'),
    ('USER_SELINUX_ERR', 'ses'),
    ('USER_START', 'ses'),
    ('USYS_CONFIG', 'ses'),
    ('VIRT_CONTROL', 'ses'),
    ('VIRT_MACHINE_ID', 'ses'),
    ('VIRT_RESOURCE', 'ses'),
    ('SYSCALL', 'sgid'),
    ('ANOM_ABEND', 'sig'),
    ('SECCOMP', 'sig'),
    ('CRYPTO_KEY_USER', 'spid'),
    ('CRYPTO_SESSION', 'spid'),
    ('USER_AVC', 'spid'),
    ('AVC', 'src'),
    ('MAC_UNLBL_STCADD', 'src_prefixlen'),
    ('MAC_UNLBL_STCDEL', 'src_prefixlen'),
    ('CRYPTO_KEY_USER', 'suid'),
    ('CRYPTO_SESSION', 'suid'),
    ('SYSCALL', 'suid'),
    ('USER_AVC', 'tpid'),
    ('ADD_GROUP', 'uid'),
    ('ADD_USER', 'uid'),
    ('ANOM_ABEND', 'uid'),
    ('ANOM_PROMISCUOUS', 'uid'),
    ('AUDIT_EVENT_LISTENER', 'uid'),
    ('CRED_ACQ', 'uid'),
    ('CRED_DISP', 'uid'),
    ('CRED_REFR', 'uid'),
    ('CRYPTO_KEY_USER', 'uid'),
    ('CRYPTO_SESSION', 'uid'),
    ('DAEMON_END', 'uid'),
    ('DAEMON_START', 'uid'),
    ('FS_RELABEL', 'uid'),
    ('LOGIN', 'uid'),
    ('ROLE_ASSIGN', 'uid'),
    ('SECCOMP', 'uid'),
    ('SYSCALL', 'uid'),
    ('USER_ACCT', 'uid'),
    ('USER_AUTH', 'uid'),
    ('USER_AVC', 'uid'),
    ('USER_CHAUTHTOK', 'uid'),
    ('USER_CMD', 'uid'),
    ('USER_END', 'uid'),
    ('USER_ERR', 'uid'),
    ('USER_LOGIN', 'uid'),
    ('USER_LOGOUT', 'uid'),
    ('USER_MAC_CONFIG_CHANGE', 'uid'),
    ('USER_ROLE_CHANGE', 'uid'),
    ('USER_SELINUX_ERR', 'uid'),
    ('USER_START', 'uid'),
    ('USYS_CONFIG', 'uid'),
    ('SERVICE_START', 'uid'),
    ('SERVICE_STOP', 'uid'),
    ('SYSTEM_BOOT', 'uid'),
    ('SYSTEM_RUNLEVEL', 'uid'),
    ('SYSTEM_SHUTDOWN', 'uid'),
    ('VIRT_CONTROL', 'uid'),
    ('VIRT_MACHINE_ID', 'uid'),
    ('VIRT_RESOURCE', 'uid'),
    ('MAC_UNLBL_ALLOW', 'unlbl_accept'),
    ('MAC_CONFIG_CHANGE', 'val'),
    ('VIRT_CONTROL', 'vm-pid'),
))

AUDIT_QUOTED_OR_HEXESC_STRING_FIELDS: FrozenSet[Tuple[str, str]] = frozenset((
    ('ADD_GROUP', 'AUID'),
    ('ADD_USER', 'AUID'),
    ('ANOM_ABEND', 'AUID'),
    ('ANOM_PROMISCUOUS', 'AUID'),
    ('CONFIG_CHANGE', 'AUID'),
    ('CRED_ACQ', 'AUID'),
    ('CRED_DISP', 'AUID'),
    ('CRED_REFR', 'AUID'),
    ('CRYPTO_KEY_USER', 'AUID'),
    ('CRYPTO_SESSION', 'AUID'),
    ('DAEMON_START', 'AUID'),
    ('DAEMON_STOP', 'AUID'),
    ('DAEMON_END', 'AUID'),
    ('FS_RELABEL', 'AUID'),
    ('LOGIN', 'AUID'),
    ('MAC_CALIPSO_ADD', 'AUID'),
    ('MAC_CALIPSO_DEL', 'AUID'),
    ('MAC_CIPSOV4_ADD', 'AUID'),
    ('MAC_CIPSOV4_DEL', 'AUID'),
    ('MAC_CONFIG_CHANGE', 'AUID'),
    ('MAC_IPSEC_EVENT', 'AUID'),
    ('MAC_MAP_ADD', 'AUID'),
    ('MAC_MAP_DEL', 'AUID'),
    ('MAC_POLICY_LOAD', 'AUID'),
    ('MAC_STATUS', 'AUID'),
    ('MAC_UNLBL_STCADD', 'AUID'),
    ('MAC_UNLBL_STCDEL', 'AUID'),
    ('SECCOMP', 'AUID'),
    ('SERVICE_START', 'AUID'),
    ('SERVICE_STOP', 'AUID'),
    ('SYSCALL', 'AUID'),
    ('SYSTEM_BOOT', 'AUID'),
    ('SYSTEM_RUNLEVEL', 'AUID'),
    ('SYSTEM_SHUTDOWN', 'AUID'),
    ('USER_ACCT', 'AUID'),
    ('USER_AUTH', 'AUID'),
    ('USER_AVC', 'AUID'),
    ('USER_CHAUTHTOK', 'AUID'),
    ('USER_CMD', 'AUID'),
    ('USER_START', 'AUID'),
    ('USER_END', 'AUID'),
    ('USER_LOGIN', 'AUID'),
    ('USER_LOGOUT', 'AUID'),
    ('USER_MAC_CONFIG_CHANGE', 'AUID'),
    ('USER_ROLE_CHANGE', 'AUID'),
    ('USER_START', 'AUID'),
    ('USER_STOP', 'AUID'),
    ('USYS_CONFIG', 'AUID'),
    ('SYSCALL', 'EGID'),
    ('SYSCALL', 'EUID'),
    ('AVC', 'FSUID'),
    ('SYSCALL', 'FSGID'),
    ('SYSCALL', 'FSUID'),
    ('ANOM_ABEND', 'GID'),
    ('ANOM_PROMISCUOUS', 'GID'),
    ('SECCOMP', 'GID'),
    ('SYSCALL', 'GID'),
    ('ADD_GROUP', 'ID'),
    ('ADD_USER', 'ID'),
    ('USER_CHAUTHTOK', 'ID'),
    ('USER_END', 'ID'),
    ('USER_LOGIN', 'ID'),
    ('USER_LOGOUT', 'ID'),
    ('USER_START', 'ID'),
    ('LOGIN', 'OLD-AUID'),
    ('PATH', 'OGID'),
    ('AVC', 'OUID'),
    ('PATH', 'OUID'),
    ('USER_AVC', 'SAUID'),
    ('SYSCALL', 'SGID'),
    ('CRYPTO_KEY_USER', 'SUID'),
    ('CRYPTO_SESSION', 'SUID'),
    ('SYSCALL', 'SUID'),
    ('ADD_GROUP', 'UID'),
    ('ADD_USER', 'UID'),
    ('ANOM_ABEND', 'UID'),
    ('ANOM_PROMISCUOUS', 'UID'),
    ('CRED_ACQ', 'UID'),
    ('CRED_DISP', 'UID'),
    ('CRED_REFR', 'UID'),
    ('CRYPTO_KEY_USER', 'UID'),
    ('CRYPTO_SESSION', 'UID'),
    ('DAEMON_START', 'UID'),
    ('FS_RELABEL', 'UID'),
    ('LOGIN', 'UID'),
    ('USER_ACCT', 'UID'),
    ('USER_AUTH', 'UID'),
    ('USER_AVC', 'UID'),
    ('USER_CHAUTHTOK', 'UID'),
    ('USER_CMD', 'UID'),
    ('USER_END', 'UID'),
    ('USER_LOGIN', 'UID'),
    ('USER_LOGOUT', 'UID'),
    ('USER_MAC_CONFIG_CHANGE', 'UID'),
    ('USER_ROLE_CHANGE', 'UID'),
    ('USER_START', 'UID'),
    ('USYS_CONFIG', 'UID'),
    ('SECCOMP', 'UID'),
    ('SERVICE_START', 'UID'),
    ('SERVICE_STOP', 'UID'),
    ('SYSCALL', 'UID'),
    ('SYSTEM_BOOT', 'UID'),
    ('SYSTEM_RUNLEVEL', 'UID'),
    ('SYSTEM_SHUTDOWN', 'UID'),
    ('CRED_ACQ', 'acct'),
    ('CRED_DISP', 'acct'),
    ('CRED_REFR', 'acct'),
    ('ROLE_ASSIGN', 'acct'),
    ('USER_ACCT', 'acct'),
    ('USER_AUTH', 'acct'),
    ('USER_CHAUTHTOK', 'acct'),
    ('USER_END', 'acct'),
    ('USER_ERR', 'acct'),
    ('USER_LOGIN', 'acct'),
    ('USER_START', 'acct'),
    ('AVC', 'addr'),
    ('AVC', 'apparmor'),
    ('USER_AVC', 'apparmor'),
    ('USYS_CONFIG', 'arg'),
    ('USER_AVC', 'bus'),
    ('AVC', 'capname'),
    ('VIRT_RESOURCE', 'cgroup'),
    ('AVC', 'class'),
    ('USER_CMD', 'cmd'),
    ('ANOM_ABEND', 'comm'),
    ('AUDIT_EVENT_LISTENER', 'comm'),
    ('AVC', 'comm'),
    ('DAEMON_END', 'comm'),
    ('NETFILTER_CFG', 'comm'),
    ('USER_AVC', 'comm'),  # This is a fake field, from adb logcat
    ('USER_MAC_CONFIG_CHANGE', 'comm'),
    ('SECCOMP', 'comm'),
    ('SERVICE_START', 'comm'),
    ('SERVICE_STOP', 'comm'),
    ('SYSCALL', 'comm'),
    ('SYSTEM_BOOT', 'comm'),
    ('SYSTEM_RUNLEVEL', 'comm'),
    ('SYSTEM_SHUTDOWN', 'comm'),
    ('CWD', 'cwd'),
    ('USER_CMD', 'cwd'),
    ('AVC', 'denied_mask'),
    ('AVC', 'dev'),
    ('VIRT_RESOURCE', 'device'),
    ('ADD_GROUP', 'exe'),
    ('ADD_USER', 'exe'),
    ('ANOM_ABEND', 'exe'),
    ('AUDIT_EVENT_LISTENER', 'exe'),
    ('CRED_ACQ', 'exe'),
    ('CRED_DISP', 'exe'),
    ('CRED_REFR', 'exe'),
    ('CRYPTO_KEY_USER', 'exe'),
    ('CRYPTO_SESSION', 'exe'),
    ('DAEMON_END', 'exe'),
    ('FS_RELABEL', 'exe'),
    ('ROLE_ASSIGN', 'exe'),
    ('SECCOMP', 'exe'),
    ('SERVICE_START', 'exe'),
    ('SERVICE_STOP', 'exe'),
    ('USER_ACCT', 'exe'),
    ('USER_AUTH', 'exe'),
    ('USER_AVC', 'exe'),
    ('USER_CHAUTHTOK', 'exe'),
    ('USER_CMD', 'exe'),
    ('USER_END', 'exe'),
    ('USER_ERR', 'exe'),
    ('USER_LOGIN', 'exe'),
    ('USER_MAC_CONFIG_CHANGE', 'exe'),
    ('USER_ROLE_CHANGE', 'exe'),
    ('USER_SELINUX_ERR', 'exe'),
    ('USER_START', 'exe'),
    ('USYS_CONFIG', 'exe'),
    ('SYSCALL', 'exe'),
    ('SYSTEM_BOOT', 'exe'),
    ('SYSTEM_RUNLEVEL', 'exe'),
    ('SYSTEM_SHUTDOWN', 'exe'),
    ('USER_LOGOUT', 'exe'),
    ('VIRT_CONTROL', 'exe'),
    ('VIRT_MACHINE_ID', 'exe'),
    ('VIRT_RESOURCE', 'exe'),
    ('AVC', 'family'),
    ('USER_AVC', 'interface'),
    ('USYS_CONFIG', 'interface'),
    ('SELINUX_ERR', 'invalid_context'),
    ('AVC', 'kmod'),
    ('USER_AVC', 'label'),
    ('USER_AVC', 'mask'),
    ('USER_AVC', 'member'),
    ('AVC', 'name'),
    ('PATH', 'name'),
    ('USER_AVC', 'name'),
    ('USYS_CONFIG', 'name'),
    ('VIRT_RESOURCE', 'new-chardev'),
    ('VIRT_RESOURCE', 'new-disk'),
    ('VIRT_RESOURCE', 'new-fs'),
    ('VIRT_RESOURCE', 'new-net'),
    ('VIRT_RESOURCE', 'old-chardev'),
    ('VIRT_RESOURCE', 'old-disk'),
    ('VIRT_RESOURCE', 'old-fs'),
    ('VIRT_RESOURCE', 'old-net'),
    ('AVC', 'operation'),
    ('USER_AVC', 'operation'),
    ('AVC', 'path'),
    ('USER_AVC', 'path'),
    ('VIRT_RESOURCE', 'path'),
    ('AVC', 'peer'),
    ('USER_AVC', 'peer_label'),
    ('PROCTITLE', 'proctitle'),
    ('AVC', 'profile'),
    ('AVC', 'requested_mask'),
    ('AVC', 'sock_type'),
    ('AVC', 'srawcon'),
    ('USER_MAC_CONFIG_CHANGE', 'tglob'),
    ('AVC', 'trawcon'),
    ('VIRT_CONTROL', 'vm'),
    ('VIRT_MACHINE_ID', 'vm'),
    ('VIRT_RESOURCE', 'vm'),
))

AUDIT_UNQUOTED_STRING_FIELDS: FrozenSet[Tuple[str, str]] = frozenset((
    ('SECCOMP', 'ARCH'),
    ('SYSCALL', 'ARCH'),
    ('SECCOMP', 'SYSCALL'),
    ('SYSCALL', 'SYSCALL'),
    ('VIRT_RESOURCE', 'acl'),
    ('USYS_CONFIG', 'args'),
    ('ANOM_PROMISCUOUS', 'dev'),
    ('ADD_GROUP', 'addr'),
    ('ADD_USER', 'addr'),
    ('CRED_ACQ', 'addr'),
    ('CRED_DISP', 'addr'),
    ('CRED_REFR', 'addr'),
    ('CRYPTO_KEY_USER', 'addr'),
    ('CRYPTO_SESSION', 'addr'),
    ('DAEMON_END', 'addr'),
    ('FS_RELABEL', 'addr'),
    ('ROLE_ASSIGN', 'addr'),
    ('SERVICE_START', 'addr'),
    ('SERVICE_STOP', 'addr'),
    ('SYSTEM_BOOT', 'addr'),
    ('SYSTEM_RUNLEVEL', 'addr'),
    ('SYSTEM_SHUTDOWN', 'addr'),
    ('USER_ACCT', 'addr'),
    ('USER_AUTH', 'addr'),
    ('USER_AVC', 'addr'),
    ('USER_CHAUTHTOK', 'addr'),
    ('USER_END', 'addr'),
    ('USER_ERR', 'addr'),
    ('USER_LOGIN', 'addr'),
    ('USER_LOGOUT', 'addr'),
    ('USER_MAC_CONFIG_CHANGE', 'addr'),
    ('USER_ROLE_CHANGE', 'addr'),
    ('USER_SELINUX_ERR', 'addr'),
    ('USER_START', 'addr'),
    ('USYS_CONFIG', 'addr'),
    ('VIRT_CONTROL', 'addr'),
    ('VIRT_MACHINE_ID', 'addr'),
    ('VIRT_RESOURCE', 'addr'),
    ('MAC_CONFIG_CHANGE', 'bool'),
    ('MAC_CALIPSO_ADD', 'calipso_type'),
    ('VIRT_RESOURCE', 'category'),
    ('CRYPTO_SESSION', 'cipher'),
    ('MAC_CIPSOV4_ADD', 'cipso_type'),
    ('VIRT_RESOURCE', 'class'),
    ('SECCOMP', 'code'),
    ('AVC', 'daddr'),
    ('USER_ROLE_CHANGE', 'default-context'),
    ('USER_AVC', 'dest'),
    ('PATH', 'dev'),
    ('CRYPTO_KEY_USER', 'direction'),
    ('CRYPTO_SESSION', 'direction'),
    ('MAC_IPSEC_EVENT', 'dst'),
    ('MAC_MAP_ADD', 'dst'),
    ('USER_AVC', 'error_name'),
    ('AVC', 'faddr'),
    ('SOCKADDR', 'fam'),
    ('DAEMON_START', 'format'),
    ('BPRM_FCAPS', 'fe'),
    ('BPRM_FCAPS', 'fi'),
    ('BPRM_FCAPS', 'fp'),
    ('CRYPTO_KEY_USER', 'fp'),
    ('USER_MAC_CONFIG_CHANGE', 'ftype'),
    ('CRED_ACQ', 'grantors'),
    ('CRED_DISP', 'grantors'),
    ('CRED_REFR', 'grantors'),
    ('USER_ACCT', 'grantors'),
    ('USER_AUTH', 'grantors'),
    ('USER_END', 'grantors'),
    ('USER_ERR', 'grantors'),
    ('USER_START', 'grantors'),
    ('ADD_GROUP', 'hostname'),
    ('ADD_USER', 'hostname'),
    ('CRED_ACQ', 'hostname'),
    ('CRED_DISP', 'hostname'),
    ('CRED_REFR', 'hostname'),
    ('CRYPTO_KEY_USER', 'hostname'),
    ('CRYPTO_SESSION', 'hostname'),
    ('DAEMON_END', 'hostname'),
    ('FS_RELABEL', 'hostname'),
    ('ROLE_ASSIGN', 'hostname'),
    ('SERVICE_START', 'hostname'),
    ('SERVICE_STOP', 'hostname'),
    ('SYSTEM_RUNLEVEL', 'hostname'),
    ('SYSTEM_SHUTDOWN', 'hostname'),
    ('USER_ACCT', 'hostname'),
    ('USER_AUTH', 'hostname'),
    ('USER_AVC', 'hostname'),
    ('USER_CHAUTHTOK', 'hostname'),
    ('USER_END', 'hostname'),
    ('USER_ERR', 'hostname'),
    ('USER_LOGIN', 'hostname'),
    ('USER_LOGOUT', 'hostname'),
    ('USER_MAC_CONFIG_CHANGE', 'hostname'),
    ('USER_ROLE_CHANGE', 'hostname'),
    ('USER_SELINUX_ERR', 'hostname'),
    ('USER_START', 'hostname'),
    ('USYS_CONFIG', 'hostname'),
    ('VIRT_CONTROL', 'hostname'),
    ('VIRT_MACHINE_ID', 'hostname'),
    ('VIRT_RESOURCE', 'hostname'),
    ('SYSTEM_BOOT', 'hostname'),
    ('SYSTEM_RUNLEVEL', 'hostname'),
    ('SYSTEM_SHUTDOWN', 'hostname'),
    ('VIRT_MACHINE_ID', 'img-ctx'),
    ('DAEMON_START', 'kernel'),
    ('CONFIG_CHANGE', 'key'),
    ('SYSCALL', 'key'),
    ('CRYPTO_KEY_USER', 'kind'),
    ('SECCOMP', 'ip'),
    ('AVC', 'laddr'),
    ('CRYPTO_KEY_USER', 'laddr'),
    ('CRYPTO_SESSION', 'laddr'),
    ('MAC_POLICY_LOAD', 'lsm'),
    ('MAC_STATUS', 'lsm'),
    ('USER_AVC', 'lsm'),
    ('CRYPTO_SESSION', 'mac'),
    ('VIRT_MACHINE_ID', 'model'),
    ('USER_AVC', 'msgtype'),
    ('PATH', 'nametype'),
    ('VIRT_RESOURCE', 'net'),
    ('AVC', 'netif'),
    ('MAC_UNLBL_STCADD', 'netif'),
    ('MAC_UNLBL_STCDEL', 'netif'),
    ('ROLE_ASSIGN', 'new-range'),
    ('ROLE_ASSIGN', 'new-role'),
    ('ROLE_ASSIGN', 'new-seuser'),
    ('SELINUX_ERR', 'newcontext'),
    ('MAC_MAP_ADD', 'nlbl_domain'),
    ('MAC_MAP_DEL', 'nlbl_domain'),
    ('MAC_MAP_ADD', 'nlbl_protocol'),
    ('PATH', 'obj'),
    ('SYSTEM_RUNLEVEL', 'old-level'),
    ('ROLE_ASSIGN', 'old-range'),
    ('ROLE_ASSIGN', 'old-role'),
    ('ROLE_ASSIGN', 'old-seuser'),
    ('BPRM_FCAPS', 'old_pa'),
    ('BPRM_FCAPS', 'old_pe'),
    ('BPRM_FCAPS', 'old_pi'),
    ('BPRM_FCAPS', 'old_pp'),
    ('SELINUX_ERR', 'oldcontext'),
    ('ADD_GROUP', 'op'),
    ('AUDIT_EVENT_LISTENER', 'op'),
    ('BPF', 'op'),
    ('CONFIG_CHANGE', 'op'),
    ('CRED_ACQ', 'op'),
    ('CRED_DISP', 'op'),
    ('CRED_REFR', 'op'),
    ('CRYPTO_KEY_USER', 'op'),
    ('CRYPTO_SESSION', 'op'),
    ('DAEMON_END', 'op'),
    ('DAEMON_START', 'op'),
    ('MAC_IPSEC_EVENT', 'op'),
    ('NETFILTER_CFG', 'op'),
    ('ROLE_ASSIGN', 'op'),
    ('SELINUX_ERR', 'op'),
    ('TIME_ADJNTPVAL', 'op'),
    ('USER_ACCT', 'op'),
    ('USER_AUTH', 'op'),
    ('USER_END', 'op'),
    ('USER_ERR', 'op'),
    ('USER_LOGIN', 'op'),
    ('USER_LOGOUT', 'op'),
    ('USER_MAC_CONFIG_CHANGE', 'op'),
    ('USER_START', 'op'),
    ('USYS_CONFIG', 'op'),
    ('VIRT_CONTROL', 'op'),
    ('BPRM_FCAPS', 'pa'),
    ('BPRM_FCAPS', 'pe'),
    ('SELINUX_ERR', 'perms'),
    ('CRYPTO_SESSION', 'pfs'),
    ('BPRM_FCAPS', 'pi'),
    ('BPRM_FCAPS', 'pp'),
    ('USER_AVC', 'property'),
    ('PATH', 'rdev'),
    ('VIRT_RESOURCE', 'rdev'),
    ('SELINUX_ERR', 'reason'),
    ('VIRT_CONTROL', 'reason'),
    ('VIRT_RESOURCE', 'reason'),
    ('ADD_GROUP', 'res'),
    ('ADD_USER', 'res'),
    ('CRED_ACQ', 'res'),
    ('CRED_DISP', 'res'),
    ('CRED_REFR', 'res'),
    ('CRYPTO_KEY_USER', 'res'),
    ('CRYPTO_SESSION', 'res'),
    ('DAEMON_END', 'res'),
    ('DAEMON_START', 'res'),
    ('FS_RELABEL', 'res'),
    ('ROLE_ASSIGN', 'res'),
    ('SERVICE_START', 'res'),
    ('SERVICE_STOP', 'res'),
    ('SYSTEM_BOOT', 'res'),
    ('SYSTEM_RUNLEVEL', 'res'),
    ('SYSTEM_SHUTDOWN', 'res'),
    ('USER_ACCT', 'res'),
    ('USER_AUTH', 'res'),
    ('USER_CHAUTHTOK', 'res'),
    ('USER_CMD', 'res'),
    ('USER_END', 'res'),
    ('USER_ERR', 'res'),
    ('USER_LOGIN', 'res'),
    ('USER_LOGOUT', 'res'),
    ('USER_MAC_CONFIG_CHANGE', 'res'),
    ('USER_ROLE_CHANGE', 'res'),
    ('USER_START', 'res'),
    ('USYS_CONFIG', 'res'),
    ('VIRT_CONTROL', 'res'),
    ('VIRT_MACHINE_ID', 'res'),
    ('VIRT_RESOURCE', 'res'),
    ('USER_MAC_CONFIG_CHANGE', 'resrc'),
    ('VIRT_RESOURCE', 'resrc'),
    ('USYS_CONFIG', 'result'),
    ('AVC', 'saddr'),
    ('SOCKADDR', 'saddr_fam'),
    ('AVC', 'scontext'),
    ('SELINUX_ERR', 'scontext'),
    ('USER_AVC', 'scontext'),
    ('MAC_IPSEC_EVENT', 'sec_obj'),
    ('MAC_UNLBL_STCADD', 'sec_obj'),
    ('MAC_UNLBL_STCDEL', 'sec_obj'),
    ('USER_ROLE_CHANGE', 'selected-context'),
    ('SELINUX_ERR', 'seresult'),
    ('MAC_IPSEC_EVENT', 'spi'),
    ('MAC_IPSEC_EVENT', 'src'),
    ('MAC_UNLBL_STCADD', 'src'),
    ('MAC_UNLBL_STCDEL', 'src'),
    ('KERNEL', 'state'),
    ('ADD_USER', 'subj'),
    ('ADD_GROUP', 'subj'),
    ('ANOM_ABEND', 'subj'),
    ('AUDIT_EVENT_LISTENER', 'subj'),
    ('CONFIG_CHANGE', 'subj'),
    ('CRED_ACQ', 'subj'),
    ('CRED_DISP', 'subj'),
    ('CRED_REFR', 'subj'),
    ('CRYPTO_KEY_USER', 'subj'),
    ('CRYPTO_SESSION', 'subj'),
    ('DAEMON_END', 'subj'),
    ('DAEMON_START', 'subj'),
    ('FS_RELABEL', 'subj'),
    ('USER_ACCT', 'subj'),
    ('USER_END', 'subj'),
    ('USER_MAC_CONFIG_CHANGE', 'subj'),
    ('LOGIN', 'subj'),
    ('MAC_CALIPSO_ADD', 'subj'),
    ('MAC_CALIPSO_DEL', 'subj'),
    ('MAC_CIPSOV4_ADD', 'subj'),
    ('MAC_CIPSOV4_DEL', 'subj'),
    ('MAC_IPSEC_EVENT', 'subj'),
    ('MAC_MAP_ADD', 'subj'),
    ('MAC_MAP_DEL', 'subj'),
    ('MAC_UNLBL_ALLOW', 'subj'),
    ('MAC_UNLBL_STCADD', 'subj'),
    ('MAC_UNLBL_STCDEL', 'subj'),
    ('NETFILTER_CFG', 'subj'),
    ('ROLE_ASSIGN', 'subj'),
    ('SECCOMP', 'subj'),
    ('SERVICE_START', 'subj'),
    ('SERVICE_STOP', 'subj'),
    ('SYSCALL', 'subj'),
    ('SYSTEM_BOOT', 'subj'),
    ('SYSTEM_RUNLEVEL', 'subj'),
    ('SYSTEM_SHUTDOWN', 'subj'),
    ('USER_AUTH', 'subj'),
    ('USER_AVC', 'subj'),
    ('USER_CHAUTHTOK', 'subj'),
    ('USER_CMD', 'subj'),
    ('USER_ERR', 'subj'),
    ('USER_LOGIN', 'subj'),
    ('USER_LOGOUT', 'subj'),
    ('USER_ROLE_CHANGE', 'subj'),
    ('USER_SELINUX_ERR', 'subj'),
    ('USER_START', 'subj'),
    ('USYS_CONFIG', 'subj'),
    ('VIRT_CONTROL', 'subj'),
    ('VIRT_MACHINE_ID', 'subj'),
    ('VIRT_RESOURCE', 'subj'),
    ('SYSCALL', 'success'),
    ('NETFILTER_CFG', 'table'),
    ('AVC', 'tclass'),
    ('SELINUX_ERR', 'tclass'),
    ('USER_AVC', 'tclass'),
    ('AVC', 'tcontext'),
    ('SELINUX_ERR', 'tcontext'),
    ('USER_AVC', 'tcontext'),
    ('USER_MAC_CONFIG_CHANGE', 'tcontext'),
    ('ADD_GROUP', 'terminal'),
    ('ADD_USER', 'terminal'),
    ('CRED_ACQ', 'terminal'),
    ('CRED_DISP', 'terminal'),
    ('CRED_REFR', 'terminal'),
    ('CRYPTO_KEY_USER', 'terminal'),
    ('CRYPTO_SESSION', 'terminal'),
    ('DAEMON_END', 'terminal'),
    ('FS_RELABEL', 'terminal'),
    ('ROLE_ASSIGN', 'terminal'),
    ('SERVICE_START', 'terminal'),
    ('SERVICE_STOP', 'terminal'),
    ('SYSTEM_BOOT', 'terminal'),
    ('SYSTEM_RUNLEVEL', 'terminal'),
    ('SYSTEM_SHUTDOWN', 'terminal'),
    ('USER_ACCT', 'terminal'),
    ('USER_AUTH', 'terminal'),
    ('USER_AVC', 'terminal'),
    ('USER_CHAUTHTOK', 'terminal'),
    ('USER_CMD', 'terminal'),
    ('USER_END', 'terminal'),
    ('USER_ERR', 'terminal'),
    ('USER_LOGIN', 'terminal'),
    ('USER_LOGOUT', 'terminal'),
    ('USER_MAC_CONFIG_CHANGE', 'terminal'),
    ('USER_ROLE_CHANGE', 'terminal'),
    ('USER_SELINUX_ERR', 'terminal'),
    ('USER_START', 'terminal'),
    ('USYS_CONFIG', 'terminal'),
    ('VIRT_CONTROL', 'terminal'),
    ('VIRT_MACHINE_ID', 'terminal'),
    ('VIRT_RESOURCE', 'terminal'),
    ('AUDIT_EVENT_LISTENER', 'tty'),
    ('LOGIN', 'tty'),
    ('SYSCALL', 'tty'),
    ('DAEMON_END', 'unit'),
    ('SERVICE_START', 'unit'),
    ('SERVICE_STOP', 'unit'),
    ('USYS_CONFIG', 'uuid'),
    ('VIRT_CONTROL', 'uuid'),
    ('VIRT_MACHINE_ID', 'uuid'),
    ('VIRT_RESOURCE', 'uuid'),
    ('DAEMON_START', 'ver'),
    ('VIRT_CONTROL', 'virt'),
    ('VIRT_MACHINE_ID', 'virt'),
    ('VIRT_RESOURCE', 'virt'),
    ('VIRT_MACHINE_ID', 'vm-ctx'),
))


# Architectures from linux/audit.h:
# https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/audit.h
AUDIT_ARCHES: Mapping[int, str] = {
    0xc00000b7: 'AUDIT_ARCH_AARCH64',
    0xc0009026: 'AUDIT_ARCH_ALPHA',
    0x4000005d: 'AUDIT_ARCH_ARCOMPACT',
    0x0000005d: 'AUDIT_ARCH_ARCOMPACTBE',
    0x400000c3: 'AUDIT_ARCH_ARCV2',
    0x000000c3: 'AUDIT_ARCH_ARCV2BE',
    0x40000028: 'AUDIT_ARCH_ARM',
    0x00000028: 'AUDIT_ARCH_ARMEB',
    0x4000008c: 'AUDIT_ARCH_C6X',
    0x0000008c: 'AUDIT_ARCH_C6XBE',
    0x4000004c: 'AUDIT_ARCH_CRIS',
    0x400000fc: 'AUDIT_ARCH_CSKY',
    0x00005441: 'AUDIT_ARCH_FRV',
    0x0000002e: 'AUDIT_ARCH_H8300',
    0x000000a4: 'AUDIT_ARCH_HEXAGON',
    0x40000003: 'AUDIT_ARCH_I386',
    0xc0000032: 'AUDIT_ARCH_IA64',
    0x00000058: 'AUDIT_ARCH_M32R',
    0x00000004: 'AUDIT_ARCH_M68K',
    0x000000bd: 'AUDIT_ARCH_MICROBLAZE',
    0x00000008: 'AUDIT_ARCH_MIPS',
    0x80000008: 'AUDIT_ARCH_MIPS64',
    0xa0000008: 'AUDIT_ARCH_MIPS64N32',
    0x40000008: 'AUDIT_ARCH_MIPSEL',
    0xc0000008: 'AUDIT_ARCH_MIPSEL64',
    0xe0000008: 'AUDIT_ARCH_MIPSEL64N32',
    0x400000a7: 'AUDIT_ARCH_NDS32',
    0x000000a7: 'AUDIT_ARCH_NDS32BE',
    0x40000071: 'AUDIT_ARCH_NIOS2',
    0x0000005c: 'AUDIT_ARCH_OPENRISC',
    0x0000000f: 'AUDIT_ARCH_PARISC',
    0x8000000f: 'AUDIT_ARCH_PARISC64',
    0x00000014: 'AUDIT_ARCH_PPC',
    0x80000015: 'AUDIT_ARCH_PPC64',
    0xc0000015: 'AUDIT_ARCH_PPC64LE',
    0x400000f3: 'AUDIT_ARCH_RISCV32',
    0xc00000f3: 'AUDIT_ARCH_RISCV64',
    0x00000016: 'AUDIT_ARCH_S390',
    0x80000016: 'AUDIT_ARCH_S390X',
    0x0000002a: 'AUDIT_ARCH_SH',
    0x8000002a: 'AUDIT_ARCH_SH64',
    0x4000002a: 'AUDIT_ARCH_SHEL',
    0xc000002a: 'AUDIT_ARCH_SHEL64',
    0x00000002: 'AUDIT_ARCH_SPARC',
    0x8000002b: 'AUDIT_ARCH_SPARC64',
    0xc00000bf: 'AUDIT_ARCH_TILEGX',
    0x400000bf: 'AUDIT_ARCH_TILEGX32',
    0x400000bc: 'AUDIT_ARCH_TILEPRO',
    0x4000006e: 'AUDIT_ARCH_UNICORE',
    0xc000003e: 'AUDIT_ARCH_X86_64',
    0x0000005e: 'AUDIT_ARCH_XTENSA',
}

# Decode syscalls for some architectures
SYSCALLS: Mapping[str, Mapping[int, str]] = {
    'AUDIT_ARCH_X86_64': {
        0: 'read',
        1: 'write',
        2: 'open',
        3: 'close',
        4: 'stat',
        5: 'fstat',
        6: 'lstat',
        7: 'poll',
        8: 'lseek',
        9: 'mmap',
        10: 'mprotect',
        11: 'munmap',
        12: 'brk',
        13: 'rt_sigaction',
        14: 'rt_sigprocmask',
        15: 'rt_sigreturn',
        16: 'ioctl',
        17: 'pread64',
        18: 'pwrite64',
        19: 'readv',
        20: 'writev',
        21: 'access',
        22: 'pipe',
        23: 'select',
        24: 'sched_yield',
        25: 'mremap',
        26: 'msync',
        27: 'mincore',
        28: 'madvise',
        29: 'shmget',
        30: 'shmat',
        31: 'shmctl',
        32: 'dup',
        33: 'dup2',
        34: 'pause',
        35: 'nanosleep',
        36: 'getitimer',
        37: 'alarm',
        38: 'setitimer',
        39: 'getpid',
        40: 'sendfile',
        41: 'socket',
        42: 'connect',
        43: 'accept',
        44: 'sendto',
        45: 'recvfrom',
        46: 'sendmsg',
        47: 'recvmsg',
        48: 'shutdown',
        49: 'bind',
        50: 'listen',
        51: 'getsockname',
        52: 'getpeername',
        53: 'socketpair',
        54: 'setsockopt',
        55: 'getsockopt',
        56: 'clone',
        57: 'fork',
        58: 'vfork',
        59: 'execve',
        60: 'exit',
        61: 'wait4',
        62: 'kill',
        63: 'uname',
        64: 'semget',
        65: 'semop',
        66: 'semctl',
        67: 'shmdt',
        68: 'msgget',
        69: 'msgsnd',
        70: 'msgrcv',
        71: 'msgctl',
        72: 'fcntl',
        73: 'flock',
        74: 'fsync',
        75: 'fdatasync',
        76: 'truncate',
        77: 'ftruncate',
        78: 'getdents',
        79: 'getcwd',
        80: 'chdir',
        81: 'fchdir',
        82: 'rename',
        83: 'mkdir',
        84: 'rmdir',
        85: 'creat',
        86: 'link',
        87: 'unlink',
        88: 'symlink',
        89: 'readlink',
        90: 'chmod',
        91: 'fchmod',
        92: 'chown',
        93: 'fchown',
        94: 'lchown',
        95: 'umask',
        96: 'gettimeofday',
        97: 'getrlimit',
        98: 'getrusage',
        99: 'sysinfo',
        100: 'times',
        101: 'ptrace',
        102: 'getuid',
        103: 'syslog',
        104: 'getgid',
        105: 'setuid',
        106: 'setgid',
        107: 'geteuid',
        108: 'getegid',
        109: 'setpgid',
        110: 'getppid',
        111: 'getpgrp',
        112: 'setsid',
        113: 'setreuid',
        114: 'setregid',
        115: 'getgroups',
        116: 'setgroups',
        117: 'setresuid',
        118: 'getresuid',
        119: 'setresgid',
        120: 'getresgid',
        121: 'getpgid',
        122: 'setfsuid',
        123: 'setfsgid',
        124: 'getsid',
        125: 'capget',
        126: 'capset',
        127: 'rt_sigpending',
        128: 'rt_sigtimedwait',
        129: 'rt_sigqueueinfo',
        130: 'rt_sigsuspend',
        131: 'sigaltstack',
        132: 'utime',
        133: 'mknod',
        134: 'uselib',
        135: 'personality',
        136: 'ustat',
        137: 'statfs',
        138: 'fstatfs',
        139: 'sysfs',
        140: 'getpriority',
        141: 'setpriority',
        142: 'sched_setparam',
        143: 'sched_getparam',
        144: 'sched_setscheduler',
        145: 'sched_getscheduler',
        146: 'sched_get_priority_max',
        147: 'sched_get_priority_min',
        148: 'sched_rr_get_interval',
        149: 'mlock',
        150: 'munlock',
        151: 'mlockall',
        152: 'munlockall',
        153: 'vhangup',
        154: 'modify_ldt',
        155: 'pivot_root',
        156: '_sysctl',
        157: 'prctl',
        158: 'arch_prctl',
        159: 'adjtimex',
        160: 'setrlimit',
        161: 'chroot',
        162: 'sync',
        163: 'acct',
        164: 'settimeofday',
        165: 'mount',
        166: 'umount2',
        167: 'swapon',
        168: 'swapoff',
        169: 'reboot',
        170: 'sethostname',
        171: 'setdomainname',
        172: 'iopl',
        173: 'ioperm',
        174: 'create_module',
        175: 'init_module',
        176: 'delete_module',
        177: 'get_kernel_syms',
        178: 'query_module',
        179: 'quotactl',
        180: 'nfsservctl',
        181: 'getpmsg',
        182: 'putpmsg',
        183: 'afs_syscall',
        184: 'tuxcall',
        185: 'security',
        186: 'gettid',
        187: 'readahead',
        188: 'setxattr',
        189: 'lsetxattr',
        190: 'fsetxattr',
        191: 'getxattr',
        192: 'lgetxattr',
        193: 'fgetxattr',
        194: 'listxattr',
        195: 'llistxattr',
        196: 'flistxattr',
        197: 'removexattr',
        198: 'lremovexattr',
        199: 'fremovexattr',
        200: 'tkill',
        201: 'time',
        202: 'futex',
        203: 'sched_setaffinity',
        204: 'sched_getaffinity',
        205: 'set_thread_area',
        206: 'io_setup',
        207: 'io_destroy',
        208: 'io_getevents',
        209: 'io_submit',
        210: 'io_cancel',
        211: 'get_thread_area',
        212: 'lookup_dcookie',
        213: 'epoll_create',
        214: 'epoll_ctl_old',
        215: 'epoll_wait_old',
        216: 'remap_file_pages',
        217: 'getdents64',
        218: 'set_tid_address',
        219: 'restart_syscall',
        220: 'semtimedop',
        221: 'fadvise64',
        222: 'timer_create',
        223: 'timer_settime',
        224: 'timer_gettime',
        225: 'timer_getoverrun',
        226: 'timer_delete',
        227: 'clock_settime',
        228: 'clock_gettime',
        229: 'clock_getres',
        230: 'clock_nanosleep',
        231: 'exit_group',
        232: 'epoll_wait',
        233: 'epoll_ctl',
        234: 'tgkill',
        235: 'utimes',
        236: 'vserver',
        237: 'mbind',
        238: 'set_mempolicy',
        239: 'get_mempolicy',
        240: 'mq_open',
        241: 'mq_unlink',
        242: 'mq_timedsend',
        243: 'mq_timedreceive',
        244: 'mq_notify',
        245: 'mq_getsetattr',
        246: 'kexec_load',
        247: 'waitid',
        248: 'add_key',
        249: 'request_key',
        250: 'keyctl',
        251: 'ioprio_set',
        252: 'ioprio_get',
        253: 'inotify_init',
        254: 'inotify_add_watch',
        255: 'inotify_rm_watch',
        256: 'migrate_pages',
        257: 'openat',
        258: 'mkdirat',
        259: 'mknodat',
        260: 'fchownat',
        261: 'futimesat',
        262: 'newfstatat',
        263: 'unlinkat',
        264: 'renameat',
        265: 'linkat',
        266: 'symlinkat',
        267: 'readlinkat',
        268: 'fchmodat',
        269: 'faccessat',
        270: 'pselect6',
        271: 'ppoll',
        272: 'unshare',
        273: 'set_robust_list',
        274: 'get_robust_list',
        275: 'splice',
        276: 'tee',
        277: 'sync_file_range',
        278: 'vmsplice',
        279: 'move_pages',
        280: 'utimensat',
        281: 'epoll_pwait',
        282: 'signalfd',
        283: 'timerfd_create',
        284: 'eventfd',
        285: 'fallocate',
        286: 'timerfd_settime',
        287: 'timerfd_gettime',
        288: 'accept4',
        289: 'signalfd4',
        290: 'eventfd2',
        291: 'epoll_create1',
        292: 'dup3',
        293: 'pipe2',
        294: 'inotify_init1',
        295: 'preadv',
        296: 'pwritev',
        297: 'rt_tgsigqueueinfo',
        298: 'perf_event_open',
        299: 'recvmmsg',
        300: 'fanotify_init',
        301: 'fanotify_mark',
        302: 'prlimit64',
        303: 'name_to_handle_at',
        304: 'open_by_handle_at',
        305: 'clock_adjtime',
        306: 'syncfs',
        307: 'sendmmsg',
        308: 'setns',
        309: 'getcpu',
        310: 'process_vm_readv',
        311: 'process_vm_writev',
        312: 'kcmp',
        313: 'finit_module',
        314: 'sched_setattr',
        315: 'sched_getattr',
        316: 'renameat2',
        317: 'seccomp',
        318: 'getrandom',
        319: 'memfd_create',
        320: 'kexec_file_load',
        321: 'bpf',
        322: 'execveat',
        323: 'userfaultfd',
        324: 'membarrier',
        325: 'mlock2',
        326: 'copy_file_range',
        327: 'preadv2',
        328: 'pwritev2',
        329: 'pkey_mprotect',
        330: 'pkey_alloc',
        331: 'pkey_free',
        332: 'statx',
        333: 'io_pgetevents',
        334: 'rseq',
        424: 'pidfd_send_signal',
        425: 'io_uring_setup',
        426: 'io_uring_enter',
        427: 'io_uring_register',
        428: 'open_tree',
        429: 'move_mount',
        430: 'fsopen',
        431: 'fsconfig',
        432: 'fsmount',
        433: 'fspick',
        434: 'pidfd_open',
        435: 'clone3',
        436: 'close_range',
        437: 'openat2',
        438: 'pidfd_getfd',
        439: 'faccessat2',
        440: 'process_madvise',
        441: 'epoll_pwait2',
        442: 'mount_setattr',
        443: 'quotactl_fd',
        444: 'landlock_create_ruleset',
        445: 'landlock_add_rule',
        446: 'landlock_restrict_self',
        447: 'memfd_secret',
        448: 'process_mrelease',
        449: 'futex_waitv',
        450: 'set_mempolicy_home_node',
        451: 'cachestat',
        452: 'fchmodat2',
        453: 'map_shadow_stack',
        454: 'futex_wake',
        455: 'futex_wait',
        456: 'futex_requeue',
        457: 'statmount',
        458: 'listmount',
        459: 'lsm_get_self_attr',
        460: 'lsm_set_self_attr',
        461: 'lsm_list_modules',
    },
}


# IOCTL commands
IOCTL_NAMES: Mapping[int, str] = {
    0x1268: 'BLKSSZGET',
    0x1272: 'BLKGETSIZE64',
    0x2285: 'SG_IO',
    0x4520: 'EVIOCGBIT(0)',
    0x4521: 'EVIOCGBIT(1)',
    0x5331: 'CDROM_GET_CAPABILITY|SNDRV_SEQ_IOCTL_UNSUBSCRIBE_PORT',
    0x5401: 'TCGETS|SNDCTL_TMR_TIMEBASE|SNDRV_TIMER_IOCTL_NEXT_DEVICE',
    0x5405: 'TCGETA|SNDCTL_TMR_TEMPO|SNDRV_TIMER_IOCTL_GSTATUS',
    0x540f: 'TIOCGPGRP',
    0x541b: 'FIONREAD',
    0x5421: 'FIONBIO',
    0x5451: 'FIOCLEX',
    0x5452: 'FIOASYNC',
    0x54ca: 'TUNSETIFF',
    0x54cf: 'TUNGETFEATURES',
    0x54d0: 'TUNSETOFFLOAD',
    0x5501: 'UI_DEV_CREATE|SNDRV_CTL_IOCTL_CARD_INFO',
    0x5600: 'VBG_IOCTL_DRIVER_VERSION_INFO',
    0x5601: 'VBG_IOCTL_GET_VMMDEV_IO_INFO',
    0x5602: 'VBG_IOCTL_VMMDEV_REQUEST',
    0x5603: 'VBG_IOCTL_VMMDEV_REQUEST_BIG',
    0x5604: 'VBG_IOCTL_HGCM_CONNECT',
    0x5605: 'VBG_IOCTL_HGCM_DISCONNECT',
    0x5606: 'VBG_IOCTL_HGCM_CALL_32',
    0x5607: 'VBG_IOCTL_HGCM_CALL_64',
    0x5608: 'VBG_IOCTL_HGCM_CALL_WITH_USER_DATA',
    0x5609: 'VBG_IOCTL_LOG',
    0x560a: 'VBG_IOCTL_WAIT_FOR_EVENTS',
    0x560b: 'VBG_IOCTL_INTERRUPT_ALL_WAIT_FOR_EVENTS',
    0x560c: 'VBG_IOCTL_CHANGE_FILTER_MASK',
    0x560d: 'VBG_IOCTL_ACQUIRE_GUEST_CAPABILITIES',
    0x560e: 'VBG_IOCTL_CHANGE_GUEST_CAPABILITIES',
    0x560f: 'VBG_IOCTL_SET_MOUSE_STATUS',
    0x5610: 'VBG_IOCTL_SET_MOUSE_NOTIFY_CALLBACK',
    0x5611: 'VBG_IOCTL_CHECK_BALLOON',
    0x5612: 'VBG_IOCTL_CHANGE_BALLOON',
    0x5613: 'VBG_IOCTL_WRITE_CORE_DUMP',
    0x5614: 'VBG_IOCTL_DPC_LATENCY_CHECKER',
    0x563d: 'VBG_IOCTL_IDC_HGCM_FAST_CALL',
    0x563e: 'VBG_IOCTL_IDC_DISCONNECT',
    0x563f: 'VBG_IOCTL_IDC_CONNECT',
    0x8910: 'SIOCGIFNAME',
    0x8911: 'SIOCSIFLINK',
    0x8912: 'SIOCGIFCONF',
    0x8913: 'SIOCGIFFLAGS',
    0x8914: 'SIOCSIFFLAGS',
    0x8915: 'SIOCGIFADDR',
    0x8916: 'SIOCSIFADDR',
    0x8917: 'SIOCGIFDSTADDR',
    0x8918: 'SIOCSIFDSTADDR',
    0x8919: 'SIOCGIFBRDADDR',
    0x891a: 'SIOCSIFBRDADDR',
    0x891b: 'SIOCGIFNETMASK',
    0x891c: 'SIOCSIFNETMASK',
    0x8924: 'SIOCSIFHWADDR',
    0x8927: 'SIOCGIFHWADDR',
    0x8933: 'SIOCGIFINDEX',
    0xae01: 'KVM_CREATE_VM',
    0xae03: 'KVM_CHECK_EXTENSION',
    0xaf21: 'VHOST_SET_VRING_CALL',
    0xaf30: 'VHOST_NET_SET_BACKEND',
    0xfd00: 'DM_VERSION',
}


# Personality bits from linux/personality.h:
# https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/personality.h
PERSONALITY_BITS: Tuple[Tuple[int, str], ...] = (
    (0x0020000, 'UNAME26'),
    (0x0040000, 'ADDR_NO_RANDOMIZE'),
    (0x0080000, 'FDPIC_FUNCPTRS'),
    (0x0100000, 'MMAP_PAGE_ZERO'),
    (0x0200000, 'ADDR_COMPAT_LAYOUT'),
    (0x0400000, 'READ_IMPLIES_EXEC'),
    (0x0800000, 'ADDR_LIMIT_32BIT'),
    (0x1000000, 'SHORT_INODE'),
    (0x2000000, 'WHOLE_SECONDS'),
    (0x4000000, 'STICKY_TIMEOUTS'),
    (0x8000000, 'ADDR_LIMIT_3GB'),
)


def escape_cmdline(command_line: Sequence[str]) -> str:
    """Escape a command line from a list of arguments to a string"""
    return ' '.join(shlex.quote(arg) for arg in command_line)


def split_audit_fields(type_name: str, line: str, prefix: str = ''
                       ) -> Mapping[str, Union[bytes, int, str, List[str], None]]:
    """Split fields from a line in the audit logs"""
    result: Dict[str, Union[bytes, int, str, List[str], None]] = collections.OrderedDict()
    remaining: str = line.strip()
    arch_syscalls: Optional[Mapping[int, str]] = None

    # Fields may be separated with GS=\x1d (group separator) too
    for remaining in remaining.split('\x1d'):
        # Parse 'avc:  denied  { map } for  pid=5183 comm="id" path="/usr/bin/id" ...'
        if type_name in ('AVC', 'USER_SELINUX_ERR', 'USER_AVC') and remaining.startswith('avc: '):
            if remaining.startswith('avc:  received policyload notice'):
                matches = re.match(r'avc:  received policyload notice \(seqno=([0-9]+)\)(.*)$', remaining)
                if not matches:
                    raise ValueError(f"Unable to parse AVC policyload notice line: {line!r}")
                seqno_str, remaining = matches.groups()
                result[prefix + 'avc/notice'] = 'policyload'
                result[prefix + 'avc/policyload/seqno'] = int(seqno_str)
            elif remaining.startswith('avc:  op=load_policy '):
                matches = re.match(r'avc:  op=(load_policy) (.*)$', remaining)
                if not matches:
                    raise ValueError(f"Unable to parse AVC load_policy line: {line!r}")
                avc_op, remaining = matches.groups()
                result[prefix + 'avc/op'] = avc_op
            elif remaining.startswith('avc:  received setenforce notice'):
                matches = re.match(r'avc:  received setenforce notice \(enforcing=([01]+)\)(.*)$', remaining)
                if not matches:
                    raise ValueError(f"Unable to parse AVC setenforce notice line: {line!r}")
                enforcing_str, remaining = matches.groups()
                result[prefix + 'avc/notice'] = 'setenforce'
                result[prefix + 'avc/setenforce/enforcing'] = enforcing_str != '0'
            elif remaining.startswith('avc:  netlink recvfrom: error '):
                # Parse 'avc:  netlink recvfrom: error 9  exe="/usr/lib/systemd/systemd" ...'
                matches = re.match(r'avc:  netlink recvfrom: error ([0-9]+)  (.*)$', remaining)
                if not matches:
                    raise ValueError(f"Unable to parse AVC netlink recvfrom error line: {line!r}")
                nl_rf_error, remaining = matches.groups()
                result[prefix + 'netlink_recvfrom_error'] = int(nl_rf_error)
            else:
                matches = re.match(r'avc: +(denied|granted) +\{([0-9a-z_ ]+)\} for +(.*)$', remaining)
                if not matches:
                    raise ValueError(f"Unable to parse AVC line: {line!r}")
                result[prefix + 'avc/result'], avc_perms_str, remaining = matches.groups()
                result[prefix + 'avc/perms'] = avc_perms_str.split()
            result.update(split_audit_fields(type_name, remaining, prefix=prefix + 'avc/for/'))
            continue

        if type_name in (
                'USER_ROLE_CHANGE',
                ) and remaining.startswith('pam: '):
            result.update(split_audit_fields(type_name, remaining[5:], prefix=prefix + 'pam/'))
            continue

        if type_name in (
                'MAC_CALIPSO_ADD',
                'MAC_CALIPSO_DEL',
                'MAC_CIPSOV4_ADD',
                'MAC_CIPSOV4_DEL',
                'MAC_MAP_ADD',
                'MAC_MAP_DEL',
                'MAC_UNLBL_ALLOW',
                'MAC_UNLBL_STCADD',
                'MAC_UNLBL_STCDEL',
                ) and remaining.startswith('netlabel: '):
            # Parse 'netlabel: auid=1000 ...'
            result.update(split_audit_fields(type_name, remaining[10:], prefix=prefix + 'netlabel/'))
            continue

        while remaining:
            if type_name == 'FS_RELABEL' and remaining.startswith('op=mass relabel '):
                # 'op=mass relabel' is not quoted :(
                result[prefix + 'op'] = 'mass relabel'
                remaining = remaining[len('op=mass relabel '):]
                continue
            if type_name == 'ADD_GROUP' and remaining.startswith('op=adding group to /etc/group '):
                # 'op=adding group to /etc/group' is not quoted :(
                result[prefix + 'op'] = 'adding group to /etc/group'
                remaining = remaining[len('op=adding group to /etc/group '):]
                continue
            if type_name == 'ADD_GROUP' and remaining.startswith('op=adding group to /etc/gshadow '):
                # 'op=adding group to /etc/gshadow' is not quoted :(
                result[prefix + 'op'] = 'adding group to /etc/gshadow'
                remaining = remaining[len('op=adding group to /etc/gshadow '):]
                continue
            if type_name == 'ADD_USER' and remaining.startswith('op=adding user id'):
                # 'op=adding user id=...' is not quoted :(
                result[prefix + 'op'] = 'adding user'
                remaining = remaining[len('op=adding user '):]
                continue
            if type_name == 'USER_CHAUTHTOK' and remaining.startswith('op=adding user to group '):
                # 'op=adding user to group' is not quoted :(
                result[prefix + 'op'] = 'adding user to group'
                remaining = remaining[len('op=adding user to group '):]
                continue
            if type_name == 'USER_CHAUTHTOK' and remaining.startswith('op=adding user to shadow group '):
                # 'op=adding user to shadow group' is not quoted :(
                result[prefix + 'op'] = 'adding user to shadow group'
                remaining = remaining[len('op=adding user to shadow group '):]
                continue
            if type_name == 'USER_CHAUTHTOK' and remaining.startswith('op=change max age '):
                # 'op=change max age' is not quoted :(
                result[prefix + 'op'] = 'change max age'
                remaining = remaining[len('op=change max age '):]
                continue
            if type_name == 'USER_CHAUTHTOK' and remaining.startswith('op=changing password '):
                # 'op=changing password' is not quoted :(
                result[prefix + 'op'] = 'changing password'
                remaining = remaining[len('op=changing password '):]
                continue

            if type_name == 'USER_ACCT' and remaining.startswith('pam_tally2 '):
                # "type=USER_ACCT ... msg='pam_tally2 ..." does not use key=value format
                result[prefix + 'pam_tally2'] = True
                remaining = remaining[len('pam_tally2 '):]
                continue

            if type_name == 'USER_ACCT':
                matches = re.match(r'^op=(user [a-z0-9]+ added by root to group [a-z0-9]+) (.*)$', remaining)
                if matches:
                    # "type=USER_ACCT ... msg='op=user syslog added by root to group tty ..."
                    result[prefix + 'op'], remaining = matches.groups()
                    continue

            if type_name == 'DAEMON_END' and remaining.startswith('UTC 2020 '):
                # Sometimes, DAEMON_END logs 'op=terminate ... UTC 2020 res=success'
                remaining = remaining[len('UTC 2020 '):]
                continue

            matches = re.match(r'^ *([0-9A-Za-z_-]+)=([^ ]*)(.*)$', remaining)
            if not matches:
                # Match ' a150[0]="argument_150"' in EXECVE records
                matches = re.match(r'^ *([0-9A-Za-z_-]+\[[0-9]+\])=([^ ]*)(.*)$', remaining)
            if not matches:
                raise ValueError(f"Unable to split audit fields in {type_name}: {remaining!r} in {line!r}")
            key, value, remaining = matches.groups()

            # Parse the value according to the key

            # Open a sub-section: 'SADDR={ fam=local path=/run/systemd/notify }
            if type_name == 'SOCKADDR' and key == 'SADDR' and value == '{':
                parts = remaining.split('}', 1)
                if len(parts) != 2:
                    raise ValueError(
                        f"Unable to parse braced {key} in audit fields: {remaining!r} in {line!r}")
                result.update(split_audit_fields(type_name, parts[0], prefix=prefix + 'SADDR/'))
                remaining = parts[1]
                continue

            # Unescaped message in USER_AVC: 'msg=\'avc:  denied ...''
            if type_name in (
                    'ADD_GROUP',
                    'ADD_USER',
                    'CRED_ACQ',
                    'CRED_DISP',
                    'CRED_REFR',
                    'CRYPTO_KEY_USER',
                    'CRYPTO_SESSION',
                    'DAEMON_END',
                    'FS_RELABEL',
                    'ROLE_ASSIGN',
                    'SERVICE_START',
                    'SERVICE_STOP',
                    'SYSTEM_BOOT',
                    'SYSTEM_RUNLEVEL',
                    'SYSTEM_SHUTDOWN',
                    'USER_ACCT',
                    'USER_AUTH',
                    'USER_AVC',
                    'USER_CHAUTHTOK',
                    'USER_CMD',
                    'USER_END',
                    'USER_ERR',
                    'USER_LOGIN',
                    'USER_LOGOUT',
                    'USER_MAC_CONFIG_CHANGE',
                    'USER_ROLE_CHANGE',
                    'USER_SELINUX_ERR',
                    'USER_START',
                    'USYS_CONFIG',
                    'VIRT_CONTROL',
                    'VIRT_MACHINE_ID',
                    'VIRT_RESOURCE',
                    ) and key == 'msg' and value.startswith('\''):
                if len(value) >= 2 and value.endswith('\''):
                    value = value[1:-1]
                else:
                    # Find the ending quote in the remaining
                    parts = remaining.split('\' ', 1)
                    if len(parts) == 2:
                        value = value[1:] + parts[0]
                        remaining = parts[1]
                    elif remaining.endswith('\''):
                        value = value[1:] + remaining[:-1]
                        remaining = ''
                    else:
                        # It happens that the message is truncated in several lines,
                        # when processing from systemd's journal. Too bad.
                        # Analyze the truncated line and ignore the next one.
                        value = value[1:] + remaining
                        remaining = ''
                result.update(split_audit_fields(type_name, value, prefix=prefix + 'msg/'))
                continue

            # Unescaped command-line in USER_AVC: 'cmdline="/usr/bin/dbus-broker-launch --scope system --audit"'
            # Same for lockdown reason and AppArmor info
            # Same for AppArmor AVC denied with flags:
            #   type=AVC msg=audit(...): apparmor="DENIED" operation="mount" class="mount" info="failed flags match"
            #   error=-13 profile="snap-update-ns.obs-studio" name="/boot/" pid=23972 comm="6"
            #   srcname="/var/lib/snapd/hostfs/boot/" flags="rw, bind"
            if (type_name, key) in (
                    ('USER_AVC', 'cmdline'),
                    ('AVC', 'flags'),
                    ('AVC', 'info'),
                    ('AVC', 'lockdown_reason'),
                    ('AVC', 'srcname'),
                    ) and value.startswith('"'):
                if len(value) >= 2 and value.endswith('"'):
                    result[prefix + key] = value[1:-1]
                else:
                    # Find the ending quote in the remaining
                    parts = remaining.split('" ', 1)
                    if len(parts) == 2:
                        result[prefix + key] = value[1:] + parts[0]
                        remaining = parts[1]
                    elif remaining.endswith('"'):
                        result[prefix + key] = value[1:] + remaining[:-1]
                        remaining = ''
                    else:
                        raise ValueError(
                            f"Unable to parse quoted {key} in audit fields: {remaining!r} in {line!r}")
                continue

            if type_name == 'SYSCALL' and \
                    key in ('a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6') and \
                    re.match(r'^[0-9a-f]+$', value):
                # Syscall arguments are hexadecimal integers
                sc_arg = int(value, 16)
                result[prefix + key] = hex(sc_arg) if sc_arg > 100 else sc_arg
                continue

            if type_name in ('SECCOMP', 'SYSCALL') and key == 'arch' and re.match(r'^[0-9a-f]+$', value):
                # Event SYSCALL with architecture
                arch = int(value, 16)
                arch_name = AUDIT_ARCHES.get(arch)
                if arch_name:
                    result[prefix + key] = arch_name
                    arch_syscalls = SYSCALLS.get(arch_name)
                else:
                    result[prefix + key] = f"{arch:#x}"
                    arch_syscalls = None
                continue

            if type_name in ('SECCOMP', 'SYSCALL') and key == 'syscall' and re.match(r'^[0-9]+$', value):
                # Syscall number, which can be decoded with "arch"
                syscall = int(value)
                if arch_syscalls:
                    syscall_name = arch_syscalls.get(syscall)
                    if syscall_name:
                        result[prefix + key] = f"{syscall} ({syscall_name})"
                        continue
                result[prefix + key] = f"{syscall} (UNKNOWN!)"
                continue

            if type_name == 'SYSCALL' and key == 'per' and re.match(r'^[0-9a-f]+$', value):
                # Event SYSCALL with personality
                personality = int(value, 16)
                if personality == 0:
                    result[prefix + key] = 0
                    continue
                remaining_bits = personality
                bit_names = []
                for bit, name in PERSONALITY_BITS:
                    if personality & bit:
                        bit_names.append(name)
                        remaining_bits &= ~bit
                if remaining_bits:
                    bit_names.append(hex(remaining_bits))
                joined_names = '|'.join(bit_names)
                result[prefix + key] = f"{personality:#x} ({joined_names})"
                continue

            if type_name == 'AVC' and key == 'ioctlcmd' and re.match(r'^0x[0-9a-f]+$', value):
                # ioctl command is written with 0x prefix
                ioctl_cmd = int(value[2:], 16)
                ioctl_name = IOCTL_NAMES.get(ioctl_cmd)
                if ioctl_name:
                    result[prefix + key] = f"{ioctl_cmd:#x}({ioctl_name})"
                else:
                    result[prefix + key] = f"{ioctl_cmd:#x}"
                continue

            if type_name == 'MMAP' and key == 'flags' and re.match(r'^0x[0-9a-f]+$', value):
                # MMAP flags is written with 0x prefix, keep it this way for now
                result[prefix + key] = value
                continue

            if type_name == 'PATH' and key == 'mode' and re.match(r'^0[0-7]+$', value):
                # mode is octal
                result[prefix + key] = int(value, 8)
                continue

            if type_name == 'SOCKADDR' and key == 'saddr' and re.match(r'^([0-9A-F][0-9A-F])+$', value):
                # Decode in bytes SOCKADDR's 'saddr=01002F72756E2F73797374656D642F6E6F7469667900'
                result[prefix + key] = binascii.unhexlify(value)
                continue

            if (type_name, key) in AUDIT_DECIMAL_INTEGER_FIELDS:
                if re.match(r'^(-?)[0-9]+$', value):
                    # Decimal integers
                    result[prefix + key] = int(value)
                    continue
                if value == 'n/a':
                    # auid can be "n/a"
                    result[prefix + key] = None
                    continue

            if (type_name, key) in AUDIT_QUOTED_OR_HEXESC_STRING_FIELDS or \
                    (type_name == 'EXECVE' and re.match(r'^a[0-9]+', key)):
                # Quoted or hex-escaped strings
                if len(value) >= 2 and value[0] == '"' == value[-1]:
                    result[prefix + key] = value[1:-1]
                    continue
                if re.match(r'^([0-9A-F][0-9A-F])+$', value):
                    result[prefix + key] = binascii.unhexlify(value).decode('utf-8', 'replace')
                    continue
                if type_name == 'PATH' and key == 'name' and value == '(null)':
                    result[prefix + key] = None
                    continue
                if (type_name, key) in (
                        ('ROLE_ASSIGN', 'exe'),
                        ('SELINUX_ERR', 'invalid_context'),
                        ('USER_AVC', 'interface'),
                        ('USER_AVC', 'member'),
                        ):
                    # The value may be directly written too!
                    result[prefix + key] = value
                    continue
                logger.warning("Quoted %s%s was unquoted in audit fields: %r in %s, %r",
                               prefix, key, value, type_name, line)

            if (type_name, key) in AUDIT_UNQUOTED_STRING_FIELDS:
                # Unquoted identifiers
                if len(value) >= 2 and value[0] == '"' == value[-1]:
                    # Warn that an unquoted identifier has been seen quoted
                    logger.warning("Unquoted %s%s was quoted in audit fields: %r in %s, %r",
                                   prefix, key, value, type_name, line)
                result[prefix + key] = value
                continue

            # Warn about unknown fields and add them
            logger.warning("Found unknown key in %s: %s%s = %r", type_name, prefix, key, value)
            result[prefix + key] = value
    return result


class SELinuxAuditLogAnalyzer:
    """Analyze SELinux audit logs"""
    def __init__(self, argv: Optional[Sequence[str]] = None):
        parser = argparse.ArgumentParser(description="Parse SELinux audit log")
        parser.add_argument('logfiles', metavar='LOGFILES', nargs='*', type=str,
                            help=f"path to audit.log (default: {DEFAULT_AUDIT_LOG_PATH})")
        group = parser.add_mutually_exclusive_group(required=False)
        group.add_argument('-a', '--audit', action='store_true',
                           help=f"reads {DEFAULT_AUDIT_LOG_PATH} (default if stdin is a TTY)")
        group.add_argument('-d', '--dmesg', action='store_true',
                           help="use dmesg to get the audit logs")
        group.add_argument('--dmesg-busybox', action='store_true',
                           help="use busybox dmesg to get the audit logs (implies --dmesg)")
        group.add_argument('-j', '--journal', action='store_true',
                           help="use systemd's journal to get the audit logs")
        group.add_argument('-l', '--logcat', action='store_true',
                           help="use ADB logcat to get the audit logs")
        group.add_argument('--stdin', action='store_true',
                           help="show audit logs from the standard input (default when it is not a TTY)")
        group.add_argument('-t', '--today', action='store_true',
                           help="show audit logs of today (using ausearch --start today)")

        parser.add_argument('-C', '--no-color', action='store_true',
                            help="do not color the output")
        parser.add_argument('-n', '--num', type=int,
                            help="cut the log to this number of lines")
        parser.add_argument('-f', '--follow', action='store_true',
                            help="follow the log (tail -F)")
        parser.add_argument('-i', '--forward-stdin', action='store_true',
                            help="forward the standard input to the launched command")
        parser.add_argument('-s', '--sudo', action='store_true',
                            help="use sudo to become root")
        parser.add_argument('-S', '--show-other', action='store_true',
                            help="show audit logs from other types that SELinux-focused ones")
        parser.add_argument('--seccomp', action='store_true',
                            help="show AUDIT_SECCOMP entries in audit logs too")
        parser.add_argument('-A', '--adb', action='store_true',
                            help="connect to a device with ADB (Android Debug Bridge)")
        parser.add_argument('-V', '--vagrant', action='store_true',
                            help="ssh into a vagrant virtual machine here to grab its audit log")
        parser.add_argument('-M', '--machine', type=str,
                            help="ssh into a machine to grab its audit log (-VM for Vagrant VM)")
        args = parser.parse_args(argv)

        # Use \r\n as line terminator in order to work around SSH setting the terminal as raw
        logging.basicConfig(
            format='[%(levelname)s] %(message)s\r',
            level=logging.DEBUG)

        self.from_dmesg: bool = args.dmesg or args.dmesg_busybox
        self.from_logcat: bool = args.logcat
        self.show_other: bool = args.show_other
        self.show_seccomp: bool = args.seccomp
        self.last_show_evt_idx: Optional[int] = None
        self.forward_stdin: bool = args.forward_stdin

        if args.no_color:
            self.color_red: str = ''
            self.color_boldred: str = ''
            self.color_green: str = ''
            self.color_yellow: str = ''
            self.color_purple: str = ''
            self.color_cyan: str = ''
            self.color_norm: str = ''
        else:
            self.color_red = COLOR_RED
            self.color_boldred = COLOR_BOLDRED
            self.color_green = COLOR_GREEN
            self.color_yellow = COLOR_YELLOW
            self.color_purple = COLOR_PURPLE
            self.color_cyan = COLOR_CYAN
            self.color_norm = COLOR_NORM

        # Record the day the program started, so that the date is displayed if th programs run for several days
        self.prog_start_date = datetime.datetime.now(tz=tzlocal()).strftime('%Y-%m-%d')

        # Build a command line for the application to launch
        if self.from_dmesg:
            # Use kernel logs (dmesg)
            if args.logfiles:
                parser.error("Option --dmesg is mutually exclusive with log files")
            if args.num is not None:
                parser.error("Option -n is not supported with dmesg source")
            if args.dmesg_busybox:
                command_line = ['busybox', 'dmesg']
            else:
                command_line = ['dmesg', '--color=never']
            if args.follow:
                command_line.append('-w')
        elif args.journal:
            # Use systemd's journal
            if args.logfiles:
                parser.error("Option --journal is mutually exclusive with log files")
            command_line = ['journalctl', '-b', '--identifier=audit', '--no-pager', '--output=short-iso']
            if args.num is not None:
                command_line.append(f'--lines={args.num}')
            if args.follow:
                command_line.append('--follow')
        elif args.logcat:
            # Use adb logcat, limited to messages with the word "audit"
            if args.follow:
                command_line = ['adb', 'logcat', '--regex=audit']
            else:
                # Option "Don't block"
                command_line = ['adb', 'logcat', '-d', '--regex=audit']
        elif args.today:
            # Use ausearch --start today
            if args.logfiles:
                parser.error("Option --today is mutually exclusive with log files")
            if args.num is not None:
                parser.error("Option -n is not supported with ausearch source")
            if args.follow:
                parser.error("Option -f is not supported with ausearch source")
            command_line = ['ausearch', '--start', 'today']
        else:
            # Use audit's log files or the standard input
            if args.audit:
                if args.logfiles:
                    parser.error("Option --audit is mutually exclusive with log files")
                logfiles = [DEFAULT_AUDIT_LOG_PATH]
            elif args.stdin:
                if args.logfiles:
                    parser.error("Option --stdin is mutually exclusive with log files")
                logfiles = ['/dev/stdin']
                self.forward_stdin = True
            elif args.logfiles:
                logfiles = args.logfiles
            elif os.isatty(sys.stdin.fileno()):
                # Use audit.log by default if the standard input is a TTY
                logfiles = [DEFAULT_AUDIT_LOG_PATH]
            else:
                # Use stdin input
                logfiles = ['/dev/stdin']
                self.forward_stdin = True

            if args.follow:
                # Use "+0" to start at the beginning, if --num has not been used
                command_line = ['tail', '-F', '-n', '+0' if args.num is None else str(args.num)]
            elif args.num is not None:
                command_line = ['tail', '-n', str(args.num)]
            else:
                command_line = ['cat']

            command_line += logfiles

        if args.sudo or args.vagrant:  # Vagrant also needs sudo
            command_line = ['sudo', '-s'] + command_line

        if args.adb:
            if self.from_dmesg:
                # Running "dmesg" on Android requires root privileges
                # Also, dmesg does not support --color option
                command_line = [arg for arg in command_line if arg != '--color=never']
                command_line = ['adb', 'shell', 'su', 'root', escape_cmdline(command_line)]
            elif self.from_logcat:
                # The logcat command handler already inserted "adb"
                assert 'adb' in command_line
            else:
                parser.error("Option --adb requires using --dmesg or --logcat source")

        if args.vagrant:
            # Use Vagrant to run a command
            if args.machine:
                command_line = ['vagrant', 'ssh', args.machine, '-c', escape_cmdline(command_line)]
            else:
                command_line = ['vagrant', 'ssh', '-c', escape_cmdline(command_line)]
        elif args.machine:
            command_line = ['ssh', args.machine, escape_cmdline(command_line)]

        self.command_line: Sequence[str] = command_line

    def spawn_command_for_audit_log(self) -> int:
        """Spawn a process from a command to read the audit log"""
        logger.debug("Running %r", escape_cmdline(self.command_line))
        proc = subprocess.Popen(
            self.command_line,
            # Forward input to the child process if an option is given
            stdin=None if self.forward_stdin else subprocess.DEVNULL,
            stdout=subprocess.PIPE,  # Grab the output
            stderr=None,  # Show errors to the console directly
        )
        current_year: str = datetime.datetime.now(tz=tzlocal()).strftime('%Y')
        assert proc.stdout is not None
        try:
            for raw_line in proc.stdout:
                # Remove coloring escape sequences (from journalctl)
                raw_line = raw_line.replace(b'\x1b[0;34m', b'').replace(b'\x1b[0m', b'')
                try:
                    # Audit logs are always ASCII
                    # '\0' could happen in corrupted journal files
                    line: str = raw_line.decode('ascii').strip('\0').strip()
                except UnicodeDecodeError:
                    continue

                if not line:
                    continue

                if self.from_dmesg:
                    # Strip the prefix after the timestamp, and accept both
                    # Linux messages ("[1.2] audit: ...")
                    # and Android ones ("[  1.2] type=1400 audit(3.4:56): ...")
                    matches = re.match(r'^\[ *[0-9.]+\] audit: (.*)$', line)
                    if not matches:
                        matches = re.match(r'^\[ *[0-9.]+\] (type=[0-9]+ audit\(.*)$', line)
                    if matches:
                        # Ignore some lines
                        audit_line = matches.group(1)
                        if audit_line != 'initializing netlink subsys (disabled)':
                            self.analyze_audit_line(audit_line)
                    # When using dmesg, ignore all lines that do not match
                    continue

                if self.from_logcat:
                    # Match lines such as:
                    #     01-01 00:00:20.632     1     1 W /system/bin/init:
                    #     type=1107 audit(0.0:5): uid=0 auid=4294967295 ...
                    # The command name is 8-character wide, such as "ls      "
                    # or a kernel task ID such as "[ T1819]"
                    matches = re.match(
                        r'^([0-9-]+ [0-9:.]+) +[0-9]+ +[0-9]+ +[A-Z]+ (.{8}[^ ]*) audit: (.*)$',
                        line)
                    if not matches:
                        matches = re.match(
                            r'^([0-9-]+ [0-9:.]+) +[0-9]+ +[0-9]+ +[A-Z]+ (.{8}[^ ]*): (type=[0-9]+ audit\(.*)$',
                            line)
                    if matches:
                        # Insert an artificial "comm" field in the audit record, to track the command name
                        time_str, comm, audit_line = matches.groups()
                        if audit_line != 'initializing netlink subsys (disabled)':
                            # Insert the current year in the log line
                            entry_time = datetime.datetime.strptime(
                                f'{current_year}!{time_str}',
                                '%Y!%m-%d %H:%M:%S.%f',
                            )
                            comm = comm.strip().replace('\\', '\\\\').replace('"', '\\"').replace(' ', '_')
                            audit_line += f' comm="{comm}"'
                            self.analyze_audit_line(audit_line, entry_time=entry_time)
                    # When using adb logcat, ignore all lines that do not match
                    continue

                # Match audit.log entries
                if re.match(r'^type=([0-9A-Z_]+|UNKNOWN\[[0-9]+\]) msg=audit', line):
                    self.analyze_audit_line(line)
                    continue

                # Try to match systemd's journal entries using ISO timestamps
                first_parts = line.split(' ', 3)
                if re.match(r'^[0-9]+-[0-9]+-[0-9]+T[0-9][0-9]:[0-9][0-9]:[0-9][0-9][0-9+-]*$', first_parts[0]):
                    if len(first_parts) != 4 or not first_parts[2].startswith('audit'):
                        logger.warning("Unexpected line prefix for journal: %r", first_parts[:3])
                        continue

                    self.analyze_audit_line(
                        first_parts[3],
                        entry_time=datetime.datetime.strptime(first_parts[0], '%Y-%m-%dT%H:%M:%S%z'),
                    )
                    continue

                # Skip the journald prolog line
                if line.startswith('-- Logs begin at '):
                    continue

                # Skip lines from ausearch like "time->Thu  1 Jan 00:00:00 UTC 1970"
                if line == '----' or re.match(r'time->\S+ \S+ [0-9]+ [0-9:]+ [0-9]{4}$', line):
                    continue

                logger.warning("Skipping unknown line %r", line)
        finally:
            if proc.poll() is None:
                proc.send_signal(signal.SIGHUP)
                proc.terminate()
                proc.wait(timeout=5)

        exit_code: int = proc.wait()
        if exit_code:
            logger.warning("Command %r exited with code %d", self.command_line, exit_code)
        return exit_code

    def analyze_audit_line(self, line: str, entry_time: Optional[datetime.datetime] = None) -> None:
        """Analyze a line from Linux audit log"""
        # The first field is the type, either numerical or textual:
        # - audit.log uses "type=AVC msg=audit(...:...): pid=..."
        # - audit.log may use "type=UNKNOWN[1332]" for messages that are not known yet to auditd
        # - dmesg uses "type=1400 audit(...:...): pid=..."
        # - systemd's journal uses "AVC pid=..."
        matches = re.match(r'^(?:type=)?(?:([0-9]+)|([0-9A-Z_]+)|(?:UNKNOWN\[([0-9]+)\])) (.*)$', line)
        if not matches:
            logger.error("Invalid audit line: %r", line)
            return
        type_intstr, type_name, type_unk, remaining = matches.groups()
        if type_unk:
            assert not type_name
            assert not type_intstr
            type_intstr = type_unk  # Process the audit type integer
        if type_intstr:
            assert not type_name
            try:
                type_name = AUDIT_TYPES[int(type_intstr)]
            except KeyError:
                logger.error("Unknown audit type %r in %r", type_intstr, line)
                raise NotImplementedError(f"Audit type {type_intstr!r} is not known yet")

        assert type_name

        # Parse the time and event index, if any
        evt_idx = None
        matches = re.match(r'^(?:msg=)?audit\(([0-9]+)\.([0-9]+):([0-9]+)\): (.*)$', remaining)
        if matches:
            seconds, millis, evt_idx_str, remaining = matches.groups()
            if seconds == '0' and millis == '0':
                # Skip parsing "fake" time given by adb logcat
                pass
            elif len(millis) != 3:
                logger.error("Invalid audit timestamp (ms) %r in %r", millis, line)
                raise ValueError(f"Invalid audit timestamp ({millis} ms)")
            else:
                entry_time = datetime.datetime.fromtimestamp(int(seconds), tz=tzlocal())
                entry_time += datetime.timedelta(milliseconds=int(millis))
            evt_idx = int(evt_idx_str)

        # Keep the event if its index matches the previous one
        related_to_previous = evt_idx is not None and evt_idx == self.last_show_evt_idx
        if related_to_previous:
            pass
        if self.show_other:
            pass
        elif type_name in AUDIT_TYPES_FOR_SELINUX:
            pass
        elif self.show_seccomp and type_name == 'SECCOMP':
            pass
        else:
            # logger.debug("Skipping audit %r from %s: %r", type_name, entry_time, remaining)
            self.last_show_evt_idx = None
            return

        parsed_record = split_audit_fields(type_name, remaining)

        # Ignore notices for policyload and setenforce
        if parsed_record.get('msg/avc/notice') in ('policyload', 'setenforce'):
            return
        if parsed_record.get('msg/avc/op') == 'load_policy':
            return

        # Ignore AppArmor profile load
        if parsed_record.get('apparmor') == 'STATUS':
            if parsed_record.get('operation') in ('profile_load', 'profile_replace'):
                return

        self.last_show_evt_idx = evt_idx

        assert entry_time is not None
        entry_date = entry_time.strftime('%Y-%m-%d')
        if entry_date == self.prog_start_date:
            # Do not write the date if it is "today", but write it if the program ran several days.
            entry_formated_time = entry_time.strftime('%H:%M:%S')
        else:
            entry_formated_time = f"{entry_date} {entry_time.strftime('%H:%M:%S')}"
        if related_to_previous and type_name != 'AVC':
            # Indent fields, for new events related to the previous line
            if type_name == 'CWD' and list(parsed_record.keys()) == ['cwd']:
                cwd = parsed_record['cwd']
                print(f"    + {type_name}: {cwd!r}", end='\r\n')
            elif type_name == 'PATH':
                # Format a PATH entry on few lines (they appear in audit.log when audit rules are configured)
                path_desc = ''
                path_name = parsed_record.get('name')
                if path_name:
                    assert isinstance(path_name, str)
                    path_desc += path_name
                else:
                    path_desc += '(no name)'
                path_mode = parsed_record.get('mode')
                if path_mode:
                    assert isinstance(path_mode, int)
                    path_desc += f" mode={oct(path_mode)}"
                path_ouid = parsed_record.get('ouid')
                path_ogid = parsed_record.get('ogid')
                if path_ouid or path_ogid:
                    assert isinstance(path_ouid, int)
                    assert isinstance(path_ogid, int)
                    path_desc += f" owner={path_ouid}:{path_ogid}"
                path_rdev = parsed_record.get('rdev')
                if path_rdev is not None and path_rdev != '00:00':
                    path_desc += f" rdev={path_rdev!r}"
                path_nametype = parsed_record['nametype']
                if path_nametype == 'UNKNOWN':
                    path_desc += " nametype=unknown"
                elif path_nametype != 'NORMAL':
                    path_desc += f" nametype={path_nametype!r}"
                path_obj = parsed_record.get('obj')
                if path_obj:
                    path_desc += f" obj={path_obj!r}"
                path_item = parsed_record.get('item')
                if path_item:
                    assert isinstance(path_item, int)
                    path_desc += f" item={path_item}"
                path_cap_fp = parsed_record['cap_fp']
                path_cap_fi = parsed_record['cap_fi']
                path_cap_fe = parsed_record['cap_fe']
                path_cap_fver = parsed_record['cap_fver']
                if path_cap_fp or path_cap_fi or path_cap_fe or path_cap_fver:
                    assert isinstance(path_cap_fp, int)
                    assert isinstance(path_cap_fi, int)
                    assert isinstance(path_cap_fe, int)
                    assert isinstance(path_cap_fver, int)
                    path_desc += f" cap=[p={path_cap_fp:#x},i={path_cap_fi:#x},e={path_cap_fe:#x},ver={path_cap_fver}]"
                path_cap_frootid = parsed_record.get('cap_frootid')
                if path_cap_frootid:
                    assert isinstance(path_cap_frootid, int)
                    path_desc += f" cap_frootid={path_cap_frootid}"
                print(f"    + {type_name}: {path_desc}", end='\r\n')
                for key, value in parsed_record.items():
                    if key in (
                            'cap_fe', 'cap_fi', 'cap_fp', 'cap_fver',
                            'cap_frootid',
                            'inode',
                            'item',
                            'mode',
                            'name',
                            'nametype',
                            'obj',
                            'ogid', 'ouid',
                            'rdev',
                            ):
                        continue
                    print(f"        - {key} = {value!r}", end='\r\n')
            elif type_name == 'PROCTITLE' and list(parsed_record.keys()) == ['proctitle']:
                # Process title has a single entry
                proc_title = parsed_record['proctitle']
                assert isinstance(proc_title, str)
                proc_title = proc_title.replace('\0', ' ')
                print(f"    + {type_name}: {proc_title!r}", end='\r\n')
            elif type_name == 'SYSCALL':
                # Format a SYSCALL entry on few lines (they appear in Debian's audit.log for example)
                sysc_syscall = parsed_record['syscall']
                sysc_exit = parsed_record.get('exit')
                sysc_args: List[str] = []
                with suppress(KeyError):
                    for arg_key in ('a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6'):
                        sysc_args.append(str(parsed_record[arg_key]))
                assert isinstance(sysc_syscall, str)
                if sysc_exit is None:
                    sysc_exit = '?'
                else:
                    assert isinstance(sysc_exit, int)
                sysc_desc = f"{sysc_syscall} ({','.join(sysc_args)})={sysc_exit}"
                sysc_ppid = parsed_record['ppid']
                if sysc_ppid != 1:  # Skip if the PPID is init
                    assert isinstance(sysc_ppid, int)
                    sysc_desc += f" ppid={sysc_ppid}"
                sysc_uid = parsed_record['uid']
                if sysc_uid != 0:  # Skip if the UID is root
                    assert isinstance(sysc_uid, int)
                    sysc_desc += f" uid={sysc_uid}"
                for uid_key in ('euid', 'suid', 'fsuid'):
                    with suppress(KeyError):
                        uid_value = parsed_record[uid_key]
                        assert isinstance(uid_value, int)
                        if uid_value != sysc_uid:
                            sysc_desc += f" {uid_key}={uid_value}"
                # Audit UID is special, as it can be -1 in 32 bits
                with suppress(KeyError):
                    uid_value = parsed_record['auid']
                    assert isinstance(uid_value, int)
                    if uid_value != sysc_uid:
                        if uid_value == 0xffffffff:
                            sysc_desc += " auid=-1"
                        else:
                            sysc_desc += f" auid={uid_value}"
                sysc_gid = parsed_record['gid']
                if sysc_gid != 0:  # Skip if the GID is root
                    assert isinstance(sysc_gid, int)
                    sysc_desc += f" gid={sysc_gid}"
                for gid_key in ('egid', 'sgid', 'fsgid'):
                    with suppress(KeyError):
                        gid_value = parsed_record[gid_key]
                        assert isinstance(gid_value, int)
                        if gid_value != sysc_gid:
                            sysc_desc += f" {gid_key}={gid_value}"
                sysc_tty = parsed_record['tty']
                assert isinstance(sysc_tty, str)
                if sysc_tty != '(none)':
                    sysc_desc += f" tty={sysc_tty}"
                print(f"    + {type_name}: {sysc_desc}", end='\r\n')
                print(f"        - exe={parsed_record['exe']!r}", end='\r\n')
                for key, value in parsed_record.items():
                    if key in (
                            'syscall', 'exit',
                            'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6',
                            'pid',  # Already in the main event
                            'ppid',
                            'uid', 'euid', 'suid', 'fsuid', 'auid',
                            'gid', 'egid', 'sgid', 'fsgid',
                            'tty',
                            'comm',  # Already in the main event
                            'exe',
                            'subj',
                            'arch',
                            'success',
                            'items',
                            'ses',
                            ):
                        continue
                    if value in ('(none)', '(null)'):
                        continue
                    print(f"        - {key} = {value!r}", end='\r\n')
            else:
                print(f"    + {type_name}:", end='\r\n')
                for key, value in parsed_record.items():
                    print(f"        - {key} = {value!r}", end='\r\n')
        elif type_name == 'AVC' and 'apparmor' in parsed_record:  # AppArmor AVC
            apparmor_result = parsed_record['apparmor']
            assert isinstance(apparmor_result, str)
            operation = parsed_record['operation']
            assert isinstance(operation, str)
            used_keys = {'apparmor', 'operation'}
            avc_desc = type_name
            if apparmor_result == 'DENIED':
                avc_desc += f" {self.color_red}{apparmor_result}{self.color_norm}"
            elif apparmor_result == 'ALLOWED':
                avc_desc += f" {self.color_green}{apparmor_result}{self.color_norm}"
            else:
                avc_desc += f" {apparmor_result}"

            avc_desc += f" {self.color_boldred}{operation}{self.color_norm}"

            if operation == 'capable':
                capability = parsed_record['capability']
                assert isinstance(capability, int)
                capname = parsed_record['capname']
                assert isinstance(capname, str)
                used_keys.add('capability')
                used_keys.add('capname')
                avc_desc += f"({self.color_cyan}{capname}{self.color_norm}"
                avc_desc += f"={self.color_yellow}{capability}{self.color_norm})"
            elif operation in ('file_mmap', 'mknod', 'open'):
                name = parsed_record['name']
                requested_mask = parsed_record['requested_mask']
                assert isinstance(requested_mask, str)
                denied_mask = parsed_record['denied_mask']
                assert isinstance(denied_mask, str)
                used_keys.add('name')
                used_keys.add('requested_mask')
                used_keys.add('denied_mask')
                if requested_mask == denied_mask:
                    arg_mask = denied_mask
                else:
                    arg_mask = f"{requested_mask}->{denied_mask})"
                avc_desc += f"({self.color_cyan}{name!r}{self.color_norm},"
                avc_desc += f" {self.color_yellow}{arg_mask}{self.color_norm})"

            with suppress(KeyError):
                avc_desc += f" profile={parsed_record['profile']!r}"
            used_keys.add('profile')
            with suppress(KeyError):
                avc_desc += f" comm={parsed_record['comm']!r}"
            used_keys.add('comm')
            with suppress(KeyError):
                avc_desc += f" pid={parsed_record['pid']!r}"
            used_keys.add('pid')
            with suppress(KeyError):
                avc_desc += f" fsuid={parsed_record['fsuid']!r}"
                avc_desc += f"({parsed_record['FSUID']!r})"
            used_keys.add('fsuid')
            used_keys.add('FSUID')
            with suppress(KeyError):
                avc_desc += f" ouid={parsed_record['ouid']!r}"
                avc_desc += f"({parsed_record['OUID']!r})"
            used_keys.add('ouid')
            used_keys.add('OUID')
            with suppress(KeyError):
                avc_desc += f" class={parsed_record['class']!r}"
            used_keys.add('class')
            print(f"[{entry_formated_time}] {avc_desc}", end='\r\n')
            for key, value in parsed_record.items():
                if key in used_keys:
                    continue
                if value in ('?', '', None):
                    continue
                print(f"    - {key} = {value!r}", end='\r\n')
        elif type_name == 'AVC' and 'avc/result' in parsed_record:  # SELinux AVC
            avc_result = parsed_record['avc/result']
            assert isinstance(avc_result, str)
            assert isinstance(parsed_record['avc/perms'], list)
            avc_perms = ' '.join(str(p) for p in parsed_record['avc/perms'])
            avc_scontext = parsed_record['avc/for/scontext']
            assert isinstance(avc_scontext, str)
            source_type = avc_scontext.split(':')[2]
            avc_tcontext = parsed_record['avc/for/tcontext']
            assert isinstance(avc_tcontext, str)
            target_type = avc_tcontext.split(':')[2]
            if target_type == source_type:
                target_type = 'self'
            tclass = parsed_record.get('avc/for/tclass', '?')
            assert isinstance(tclass, str)

            avc_desc = type_name
            if parsed_record.get('avc/for/permissive') == 1:
                avc_desc += f"{self.color_green}p{self.color_norm}"
            if avc_result == 'denied':
                # Colorize AVC denials in red
                avc_desc += f" {self.color_red}{avc_result}{self.color_norm}"
            elif avc_result == 'granted':
                # Colorize AVC granted (due to "auditallow") in green
                avc_desc += f" {self.color_green}{avc_result}{self.color_norm}"
            else:
                avc_desc += f" {avc_result}"
            avc_desc += f" {self.color_purple}{source_type}{self.color_norm}"
            avc_desc += f" {self.color_yellow}{target_type}{self.color_norm}"
            avc_desc += f":{self.color_cyan}{tclass}{self.color_norm}"
            avc_desc += f" {self.color_boldred}{{ {avc_perms} }}{self.color_norm}"
            with suppress(KeyError):
                avc_ioctlcmd = parsed_record['avc/for/ioctlcmd']
                assert isinstance(avc_ioctlcmd, str)
                avc_desc += f" ioctl={avc_ioctlcmd}"
            with suppress(KeyError):
                avc_desc += f" path={parsed_record['avc/for/path']!r}"
            with suppress(KeyError):
                avc_desc += f" name={parsed_record['avc/for/name']!r}"
            with suppress(KeyError):
                avc_desc += f" (ino {parsed_record['avc/for/dev']!r}:{parsed_record['avc/for/ino']!r})"
            with suppress(KeyError):
                avc_desc += f" comm={parsed_record['avc/for/comm']!r}"
            with suppress(KeyError):
                avc_desc += f" pid={parsed_record['avc/for/pid']!r}"
            print(f"[{entry_formated_time}] {avc_desc}", end='\r\n')
            for key, value in parsed_record.items():
                if key in (
                        'avc/for/capability',
                        'avc/for/comm',
                        'avc/for/dev',
                        'avc/for/ino',
                        'avc/for/ioctlcmd',
                        'avc/for/name',
                        'avc/for/path',
                        'avc/for/permissive',
                        'avc/for/pid',
                        'avc/for/scontext',
                        'avc/for/tclass',
                        'avc/for/tcontext',
                        'avc/perms',
                        'avc/result',
                        ):
                    continue
                if value in ('?', '', None):
                    continue
                print(f"    - {key} = {value!r}", end='\r\n')
        elif type_name == 'USER_AVC' and 'msg/apparmor' in parsed_record:  # AppArmor user AVC
            apparmor_result = parsed_record['msg/apparmor']
            assert isinstance(apparmor_result, str)
            operation = parsed_record['msg/operation']
            assert isinstance(operation, str)
            used_keys = {'msg/apparmor', 'msg/operation'}
            avc_desc = type_name
            if apparmor_result == 'DENIED':
                avc_desc += f" {self.color_red}{apparmor_result}{self.color_norm}"
            elif apparmor_result == 'ALLOWED':
                avc_desc += f" {self.color_green}{apparmor_result}{self.color_norm}"
            else:
                avc_desc += f" {apparmor_result}"

            avc_desc += f" {self.color_boldred}{operation}{self.color_norm}"

            if operation == 'dbus_method_call':
                dbus_bus = parsed_record['msg/bus']
                dbus_path = parsed_record['msg/path']
                dbus_interface = parsed_record['msg/interface']
                dbus_member = parsed_record['msg/member']
                used_keys.add('msg/bus')
                used_keys.add('msg/path')
                used_keys.add('msg/interface')
                used_keys.add('msg/member')
                avc_desc += f"({self.color_cyan}{dbus_bus!r}{self.color_norm},"
                avc_desc += f" {self.color_cyan}{dbus_path!r}{self.color_norm},"
                avc_desc += f" {self.color_cyan}{dbus_interface!r}{self.color_norm},"
                avc_desc += f" {self.color_cyan}{dbus_member!r}{self.color_norm})"

            avc_desc += " (from"
            with suppress(KeyError):
                avc_desc += f" uid={parsed_record['uid']!r}"
                if parsed_record['uid'] == parsed_record['msg/sauid']:
                    used_keys.add('msg/sauid')
            used_keys.add('uid')
            with suppress(KeyError):
                if parsed_record['auid'] != 0xffffffff:
                    avc_desc += f" auid={parsed_record['auid']!r}"
            used_keys.add('auid')
            with suppress(KeyError):
                if parsed_record['ses'] != 0xffffffff:
                    avc_desc += f" ses={parsed_record['ses']!r}"
            used_keys.add('ses')
            with suppress(KeyError):
                avc_desc += f" pid={parsed_record['pid']!r}"
            used_keys.add('pid')
            avc_desc += ")"
            print(f"[{entry_formated_time}] {avc_desc}", end='\r\n')
            for key, value in parsed_record.items():
                if key in used_keys:
                    continue
                if value in ('?', '', None):
                    continue
                print(f"    - {key} = {value!r}", end='\r\n')
        elif type_name == 'USER_AVC' and 'msg/avc/result' in parsed_record:  # SELinux user AVC
            avc_result = parsed_record['msg/avc/result']
            assert isinstance(avc_result, str)
            assert isinstance(parsed_record['msg/avc/perms'], list)
            avc_perms = ' '.join(parsed_record['msg/avc/perms'])
            avc_scontext = parsed_record['msg/avc/for/scontext']
            assert isinstance(avc_scontext, str)
            source_type = avc_scontext.split(':')[2]
            avc_tcontext = parsed_record['msg/avc/for/tcontext']
            assert isinstance(avc_tcontext, str)
            target_type = avc_tcontext.split(':')[2]
            if target_type == source_type:
                target_type = 'self'
            tclass = parsed_record['msg/avc/for/tclass']
            assert isinstance(tclass, str)

            avc_desc = type_name
            if parsed_record.get('msg/avc/for/permissive') == 1:
                avc_desc += f"{self.color_green}p{self.color_norm}"
            if avc_result == 'denied':
                # Colorize AVC denials in red
                avc_desc += f" {self.color_red}{avc_result}{self.color_norm}"
            elif avc_result == 'granted':
                # Colorize AVC granted (due to "auditallow") in green
                avc_desc += f" {self.color_green}{avc_result}{self.color_norm}"
            else:
                avc_desc += f" {avc_result}"
            avc_desc += f" {self.color_purple}{source_type}{self.color_norm}"
            avc_desc += f" {self.color_yellow}{target_type}{self.color_norm}"
            avc_desc += f":{self.color_cyan}{tclass}{self.color_norm}"
            avc_desc += f" {self.color_boldred}{{ {avc_perms} }}{self.color_norm}"
            with suppress(KeyError):
                avc_desc += f" path={parsed_record['msg/avc/for/path']!r}"
            with suppress(KeyError):
                avc_desc += f" spid={parsed_record['msg/avc/for/spid']!r}"
            with suppress(KeyError):
                avc_desc += f" tpid={parsed_record['msg/avc/for/tpid']!r}"

            avc_desc += " (from"
            with suppress(KeyError):
                avc_subj = parsed_record['subj']
                assert isinstance(avc_subj, str)
                if avc_subj.startswith('system_u:system_r:system_dbusd_t'):
                    avc_desc += " subj=DBUS"
                else:
                    avc_desc += f" subj={avc_subj}"
            with suppress(KeyError):
                avc_desc += f" uid={parsed_record['uid']!r}"
            with suppress(KeyError):
                avc_desc += f" pid={parsed_record['pid']!r}"
            avc_desc += ")"
            print(f"[{entry_formated_time}] {avc_desc}", end='\r\n')
            for key, value in parsed_record.items():
                if key in (
                        'auid',
                        'msg/avc/for/path',
                        'msg/avc/for/permissive',
                        'msg/avc/for/sauid',
                        'msg/avc/for/scontext',
                        'msg/avc/for/spid',
                        'msg/avc/for/tpid',
                        'msg/avc/for/tclass',
                        'msg/avc/for/tcontext',
                        'msg/avc/perms',
                        'msg/avc/result',
                        'ses',
                        'subj',
                        'pid',
                        'uid',
                        ):
                    continue
                if value in ('?', '', None):
                    continue
                print(f"    - {key} = {value!r}", end='\r\n')
        elif type_name == 'SECCOMP':
            # Format Seccomp action SCMP_ACT_LOG (https://man7.org/linux/man-pages/man3/seccomp_rule_add.3.html)
            seccomp_syscall = parsed_record['syscall']
            assert isinstance(seccomp_syscall, str)
            seccomp_desc = f"{type_name} syscall={self.color_boldred}{seccomp_syscall}{self.color_norm}"
            if 'SYSCALL' in parsed_record:
                seccomp_usyscall = parsed_record['SYSCALL']
                assert isinstance(seccomp_usyscall, str)
                if seccomp_usyscall not in seccomp_syscall:
                    seccomp_desc += f" SYSCALL={seccomp_usyscall!r}"
            seccomp_desc += f" exe={self.color_cyan}{parsed_record['exe']!r}{self.color_norm}"
            seccomp_desc += f" comm={self.color_cyan}{parsed_record['comm']!r}{self.color_norm}"
            seccomp_desc += f" pid={parsed_record['pid']!r}"
            seccomp_uid = parsed_record['uid']
            assert isinstance(seccomp_uid, int)
            seccomp_desc += f" uid={seccomp_uid}"
            with suppress(KeyError):
                seccomp_u_uid = parsed_record['UID']
                assert isinstance(seccomp_u_uid, str)
                seccomp_desc += f"({seccomp_u_uid})"
            with suppress(KeyError):
                seccomp_auid = parsed_record['auid']
                assert isinstance(seccomp_auid, int)
                if seccomp_auid != seccomp_uid:
                    if seccomp_auid == 0xffffffff:
                        seccomp_desc += " auid=-1"
                    else:
                        seccomp_desc += f" auid={seccomp_auid}"
                    seccomp_u_auid = parsed_record['AUID']
                    assert isinstance(seccomp_u_auid, str)
                    seccomp_desc += f"({seccomp_u_auid})"
            seccomp_desc += f" gid={parsed_record['gid']!r}"
            with suppress(KeyError):
                seccomp_u_gid = parsed_record['GID']
                assert isinstance(seccomp_u_gid, str)
                seccomp_desc += f"({seccomp_u_gid})"
            with suppress(KeyError):
                seccomp_subj = parsed_record['subj']
                assert isinstance(seccomp_subj, str)
                seccomp_desc += f" subj={seccomp_subj}"
            seccomp_code = parsed_record['code']
            assert isinstance(seccomp_code, str)
            seccomp_desc += f" code={seccomp_code}"
            seccomp_ip = parsed_record['ip']
            assert isinstance(seccomp_ip, str)
            seccomp_desc += f" ip={seccomp_ip}"
            seccomp_sig = parsed_record['sig']
            assert isinstance(seccomp_sig, int)
            if seccomp_sig != 0:
                seccomp_desc += f" sig={seccomp_sig}"
            seccomp_compat = parsed_record['compat']
            assert isinstance(seccomp_compat, int)
            if seccomp_compat != 0:
                seccomp_desc += f" compat={seccomp_compat}"
            print(f"[{entry_formated_time}] {seccomp_desc}", end='\r\n')
            for key, value in parsed_record.items():
                if key in (
                        'ARCH',
                        'AUID',
                        'GID',
                        'SYSCALL',
                        'UID',
                        'arch',
                        'auid',
                        'code',
                        'comm',
                        'compat',
                        'exe',
                        'gid',
                        'ip',
                        'pid',
                        'uid',
                        'ses',
                        'sig',
                        'subj',
                        'syscall',
                        ):
                    continue
                print(f"    - {key} = {value!r}", end='\r\n')
        else:
            print(f"{self.color_yellow}[{entry_formated_time}] {type_name}:{self.color_norm}", end='\r\n')
            for key, value in parsed_record.items():
                if value in ('?', '', None):
                    continue
                print(f"{self.color_yellow}    - {key} = {value!r}{self.color_norm}", end='\r\n')


if __name__ == '__main__':
    sys.exit(SELinuxAuditLogAnalyzer().spawn_command_for_audit_log())
