#!/bin/sh
# Define aliases and exported variables for every shell

# alias may be unavailable, for example in busybox shell
if type alias > /dev/null 2> /dev/null ; then
    # Be verbose!
    alias chmod='chmod -v'
    alias chown='chown -v'
    alias mkdir='mkdir -v'
    alias mount='mount -v'
    alias umount='umount -v'
    alias ln='ln -v'
    alias rm='rm -v'
    # Be interactive when overwritting files
    alias cp='cp -iv'
    alias mv='mv -iv'

    # Shortcuts
    alias h='history'
    # Always use /usr/bin/sudo if available to prevent PATH hijacking
    # sadm alias is for SELinux
    if [ -x /usr/bin/sudo ] ; then
        alias s='/usr/bin/sudo -s'
        alias sadm='/usr/bin/sudo -r sysadm_r -t sysadm_t -s'
    else
        alias s='sudo -s'
        alias sadm='sudo -r sysadm_r -t sysadm_t -s'
    fi

    # Be human !
    alias df='df -h'
    alias du1='du -h --max-depth=1'
    alias du2='du -h --max-depth=2'

    # VIM aliases
    alias :w='echo "Save is not implemented in ${SHELL##*/} :p"'
    alias :x=':w'
    alias :q='echo "Type exit or ^D if you want to exit ${SHELL##*/}"'
    alias :wq='echo "Hey! Thats ${SHELL##*/} and *not* VI(M)!"'

    # List files, using available ls options
    # CFh = columns, classify, human
    LS_PARAMS='-CFh'
    # Option: escape non printable chars (not in busybox ash)
    if ls --help 2> /dev/null |grep -q -- --escape; then
        LS_PARAMS="$LS_PARAMS --escape"
    fi
    # Option: use colors
    if ls --help 2> /dev/null |grep -q -- --color; then
        LS_PARAMS="$LS_PARAMS --color=always"

        if ls --help 2>/dev/null |grep -q -- --time-style; then
            LS_PARAMS="$LS_PARAMS "$'--time-style="+\e[0;35m%Y-%m-%d %H:%M\e[0m"'
        fi
    fi
    alias ls="ls $LS_PARAMS"
    alias l='ls'
    alias la='ls -A'
    alias ll='ls -l'
    alias lla='ls -lsA'
    # ZSH-specific aliases
    if [ ! -z "$ZSH_VERSION" ] ; then
        alias lsd='ls -ld *(/)'                 # only show directories
        alias lad='ls -ld .*(/)'                # only show dot-directories
        alias lsa='ls -a .*(.)'                 # only show dot-files
        alias lsd='ls -d *(/)'                  # only show directories
        alias lse='ls -d *(/^F)'                # only show empty directories
        alias lsx='ls -l *(*) | head'           # only show executables
        alias lssuid='ls -l *(s,S) | head'      # only show suid-files
        alias lsbig='ls -lSh *(.) | head'       # display the biggest files
        alias lssmall='ls -Sl *(.) | tail'      # display the smallest files
        alias lsnew='ls -rtl *(.) | tail'       # display the newest files
        alias lsold='ls -rtl *(.) | head'       # display the oldest files

        # SELinux aliases
        alias lsz='ls -Z'
        alias llz='ls -lZ'

        # Remember where I've been
        alias cd='pushd'
        setopt PUSHD_SILENT
    fi

    # Get file attributes, not restricted to "^user\\."
    alias getextattr='getfattr -m - -d'

    # List processes
    alias psa='ps -A'
    alias pse='ps -efH'
    alias pss='ps -aux'
    alias psx='ps -AFH'
    alias psz='ps -efZ'
    alias pshz='ps -efHZ'

    # Shortcut to common screen options
    alias scx='screen -x'
    alias scrd='screen -RD'
    alias scls='screen -ls'

    # Clear screen with ESC + c. Ctrl+L may also work.
    alias cls='printf "\033c"'

    # Highlight grep results
    if grep --help 2> /dev/null |grep -q -- --color; then
        alias grep='grep --color=always'
    fi

    # Line-buffered grep, useful when selecting output of tail -F
    # Don't use colored output for lgrep
    if grep --help 2> /dev/null |grep -q -- --line-buffered; then
        if [ -x /bin/grep ] ; then
            alias lgrep='/bin/grep --line-buffered'
        else
            alias lgrep='grep --line-buffered'
        fi
    fi

    # OpenSSL shortcuts
    # View a certificate request (add -verify to check it)
    alias openssl-csr='openssl req -noout -text -in'
    # View a x509 certificate
    alias openssl-crt='openssl x509 -noout -text -in'
    # View a PKCS#12 file (.pfx or .p12)
    alias openssl-p12='openssl pkcs12 -info -in'
    # Make a SSL connection to IP:port
    alias openssl-connect='openssl s_client -connect'

    # Colored diff
    if which colordiff > /dev/null 2> /dev/null; then
        alias diff='colordiff -u'
        # Change svn diff.
        # You may instead put "diff-cmd = colordiff" in ~/.subversion/config
        # Use -x "-u" to show 3 lines of unified context
        # and -x "-u -w" to ignore all white space changes.
        alias svn-diff='svn diff --diff-cmd colordiff'
    else
        alias diff='diff -u'
        alias svn-diff='svn diff'
    fi
    if which most > /dev/null 2> /dev/null; then
        alias man='man -P most'
    fi

    # Colored dmesg
    if which dmesg > /dev/null 2> /dev/null && dmesg --help 2> /dev/null |grep -q -- --color; then
        alias dmesg='dmesg --color'
    fi

    # Use rsync instead of scp
    if which rsync > /dev/null 2> /dev/null; then
        # Options: archive, verbose, compress, partial&progress
        alias scp='rsync -avzP'
    fi

    # X Window bell
    if which xset > /dev/null 2> /dev/null; then
        alias xbell-off='xset b off'
        alias xbell-on='xset b on'
    fi
fi

# Some functions
# mkdir && cd
mcd() {
    mkdir "$1" && cd "$1"
}

# cd && ls
cl() {
    cd "$1" && shift && ls $*
}

# Read passwords. Zsh uses "?prompt" option to display a prompt and other
# shells (Bash, Ash, ...) use -p option, so use echo to be compatible.
read_pass() {
    echo >&2 -n 'Password: ' && read -s $* && echo ''
}

# Generate random passwords from /dev/random
# see also: openssl rand -base64 16
gen_pass() {
    head -c12 /dev/random |base64
}

# Log tail, to have colors when ccze is available
if which ccze > /dev/null 2> /dev/null; then
    ltail() {
        tail $* |ccze -A
    }
elif type alias > /dev/null 2> /dev/null ; then
    alias ltail=tail
else
    ltail() {
        tail $*
    }
fi

# Convert timestamps from Epoch to dates
epoch2date() {
    local TS
    if [ $# -ge 1 ] ; then
        while [ $# -ge 1 ] ; do
            date --date=@$1
            shift
        done
    else
        echo >&2 "Usage: $0 timestamp [...]"
    fi
}

# Retrieve HTTPS certificate of a website
get_https_cert() {
    openssl s_client -servername "$1" -connect "$1:443" < /dev/null \
         -showcerts | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p'
}
